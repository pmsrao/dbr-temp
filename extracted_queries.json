[
  {
    "displayName": "select_yes_no_tag_show_mismatch",
    "sqlQuery": "select\n    explode(array(\n    'Not Matched Only',\n    'Matched Only',\n    'All Usage'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "select_dbus_dollars_toggle",
    "sqlQuery": "select\n    explode(array(\n    'DBUs',\n    'Dollars'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "select_time_key_overview",
    "sqlQuery": "select\n    explode(array(\n    'Day',\n    'Week',\n    'Month',\n    'Quarter',\n    'Year'\n  )) as time_key",
    "parameters": []
  },
  {
    "displayName": "select_group_key",
    "sqlQuery": "select\n    explode(array(\n    'Workspace',\n    'Product',\n    'SKU' --'Photon',\n    --'Serverless'\n  )) as group_key",
    "parameters": []
  },
  {
    "displayName": "select_workspace",
    "sqlQuery": "with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest ) select\n    DISTINCT workspace_full_name\nfrom\n    workspace",
    "parameters": []
  },
  {
    "displayName": "select_tag_key",
    "sqlQuery": "with -- parse workspaces json workspace as ( select\n    explode( map_entries(from_json('$$$__WORKSPACES_JSON__$$$', 'map<string,string>')) ) as kvp, kvp['key'] as workspace_id, kvp['value'] as workspace_name ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else concat(workspace_name, ' (id: ', u.workspace_id, ')')\n    end as workspace, u.*\nfrom\n    system.billing.usage as u\n  left join\n    workspace\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    *\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    if(:param_workspace='<ALL WORKSPACES>', true, workspace = :param_workspace) -- all workspaces under account, or single workspace ),\n -- query tag_key_selection as ( select\n    distinct(explode(map_keys(custom_tags))) as tag_key\nfrom\n    usage_filtered ) select\n    *\nfrom\n    tag_key_selection",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "<ALL WORKSPACES>"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      }
    ]
  },
  {
    "displayName": "select_rank_key",
    "sqlQuery": "with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace -- Must assume this works to filter\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    usage_metadata\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) AND   (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n -- enumerate all usage_metadata keys usage_metadata_keys as ( select\n    distinct(explode( map_keys(from_json( to_json(usage_metadata),\n 'map<string,string>' )) )) as rank_key\nfrom\n    usage_filtered ) select\n    explode(array(\n    'workspace',\n    'run_as'\n  )) as rank_key union all select\n    rank_key\nfrom\n    usage_metadata_keys",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      }
    ]
  },
  {
    "displayName": "select_serverless_flag",
    "sqlQuery": "select\n    explode(array(\n    'all',\n    'Serverless',\n    'Classic'\n  )) as group_key",
    "parameters": []
  },
  {
    "displayName": "select_billing_origin_product",
    "sqlQuery": "select\n    DISTINCT billing_origin_product\nfrom\n    system.billing.usage\nwhere\n    billing_origin_product IS NOT NULL",
    "parameters": []
  },
  {
    "displayName": "select_tag_group",
    "sqlQuery": "select\n    explode(array(\n    'Tag Key-Value Pairs',\n    'Workspace',\n    'Product',\n    'SKU',\n    --'Serverless',\n    --'Photon',\n    'Matched Status'\n  )) as group_key",
    "parameters": []
  },
  {
    "displayName": "select_tag_agg_toggle",
    "sqlQuery": "select\n    explode(array(\n    'Key-Value Pairs',\n    'Keys'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "select_tag_agg_top_tags",
    "sqlQuery": "select\n    explode(array(\n    'Key-Value Pairs',\n    'Keys',\n    'Values'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "select_tag_search_mode",
    "sqlQuery": "select\n    explode(array(\n    'AND',\n    'OR'\n  )) as group_key",
    "parameters": []
  },
  {
    "displayName": "select_include_remaining",
    "sqlQuery": "select\n    explode(array(\n    'Yes',\n    'No'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "select_case_sensitivity",
    "sqlQuery": "select\n    explode(array(\n    'Yes',\n    'No'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "select_feature_flag_toggle",
    "sqlQuery": "select\n    explode(array(\n    'Enabled',\n    'Disabled'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "select_account_prices_toggle",
    "sqlQuery": "select\n    explode(array(\n    'system.billing.list_prices',\n    'system.billing.account_prices'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "select_enable_links_toggle",
    "sqlQuery": "select\n    explode(array(\n    'Enabled',\n    'Disabled'\n  )) as toggle",
    "parameters": []
  },
  {
    "displayName": "usage_overview",
    "sqlQuery": "SET ansi_mode = true; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace -- Must assume this works to filter\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    *, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = True\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) AND   (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) as usage_year, date_trunc('QUARTER', usage_date) as usage_quarter, date_trunc('MONTH', usage_date) as usage_month, date_trunc('WEEK', usage_date) as usage_week, MIN(usage_date) OVER () AS start_time, MAX(usage_date) OVER () AS end_time, u.*\nfrom\n    usage_filtered as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n -- eval time_key param list_priced_usd_with_time_key as ( select\n    identifier ( case\n      when :param_time_key = 'Year'\n      then 'usage_year' when :param_time_key = 'Quarter'\n      then 'usage_quarter' when :param_time_key = 'Month'\n      then 'usage_month' when :param_time_key = 'Week'\n      then 'usage_week' when :param_time_key = 'Day'\n      then 'usage_date'\n      else 'usage_date'\n    end )::date as time_key, *\nfrom\n    list_priced_usd ),\n list_priced_usd_with_time_and_group_keys as ( select\n    workspace as workspace_norm, case\n      when :param_group_key = 'Workspace'\n      then workspace_norm WHEN :param_group_key = 'Product'\n      then billing_origin_product WHEN :param_group_key = 'SKU'\n      then sku_name WHEN :param_group_key = 'Photon'\n      then IsPhoton WHEN :param_group_key = 'Serverless'\n      then IsServerless\n    end AS group_key, *\nfrom\n    list_priced_usd_with_time_key u ),\n clean_results AS ( -- query select\n    time_key, group_key, case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd\n    end AS usage_usd_dynamic, usage_usd, usage_unit, usage_dbus, IsServerless, workspace_norm, 'Actuals' AS usage_type, CONCAT('per ', CAST(:param_time_key AS STRING)) AS time_period, start_time AS start_time_window, end_time AS end_time_window, CONCAT(CAST(start_time AS STRING),\n ' to ', CAST(end_time AS STRING)) AS time_window_string\nfrom\n    list_priced_usd_with_time_and_group_keys ) select\n    *\nfrom\n    clean_results",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-30d/d to now/d",
        "complexType": "RANGE"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.account_prices"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Month"
      },
      {
        "displayName": "param_group_key",
        "keyword": "param_group_key",
        "dataType": "STRING",
        "defaultValue": "Product"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      }
    ]
  },
  {
    "displayName": "usage_forecast",
    "sqlQuery": "SET ansi_mode = true; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n usage_with_ws_filtered_by_date AS ( select\n    case\n      when workspace_name IS NULL\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end AS workspace, u.*\nfrom\n    system.billing.usage AS u\n  INNER join\n    workspace\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date BETWEEN :time_range.min AND :time_range.max ),\n usage_filtered AS ( select\n    *, case\n      when product_features.is_serverless = TRUE\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = TRUE\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) AND (array_contains(:is_serverless, case\n      when product_features.is_serverless = TRUE\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) AS usage_year, date_trunc('QUARTER', usage_date) AS usage_quarter, date_trunc('MONTH', usage_date) AS usage_month, date_trunc('WEEK', usage_date) AS usage_week, date_trunc('DAY', usage_date) AS usage_day, date_trunc('HOUR', usage_start_time) AS usage_hour, MIN(usage_date) OVER () AS start_time, MAX(usage_date) OVER () AS end_time, u.*\nfrom\n    usage_filtered AS u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  LEFT join\n    prices AS p\n    on u.sku_name=p.sku_name AND u.usage_unit=p.usage_unit AND (u.usage_end_time BETWEEN p.price_start_time AND p.coalesced_price_end_time) ),\n list_priced_usd_with_time_key AS ( select\n    identifier ( case\n      when :param_time_key = 'Year'\n      then 'usage_year' WHEN :param_time_key = 'Quarter'\n      then 'usage_quarter' WHEN :param_time_key = 'Month'\n      then 'usage_month' WHEN :param_time_key = 'Week'\n      then 'usage_week' WHEN :param_time_key = 'Day'\n      then 'usage_date'\n      else 'usage_date'\n    end )::date AS time_key, *\nfrom\n    list_priced_usd ),\n list_priced_usd_with_time_and_group_keys AS ( select\n    workspace AS workspace_norm, case\n      when :param_group_key = 'Workspace'\n      then workspace_norm WHEN :param_group_key = 'Product'\n      then billing_origin_product WHEN :param_group_key = 'SKU'\n      then sku_name WHEN :param_group_key = 'Photon'\n      then IsPhoton WHEN :param_group_key = 'Serverless'\n      then IsServerless\n    end AS group_key, *\nfrom\n    list_priced_usd_with_time_key u ),\n clean_results AS ( select\n    time_key, MAX(usage_hour) AS max_usage_hour, -- For intraday forecasting SUM(case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd END) AS usage_usd_dynamic, 'Actuals' AS usage_type, MIN(start_time) AS start_time_window, MAX(end_time) AS end_time_window\nfrom\n    list_priced_usd_with_time_and_group_keys GROUP BY time_key ),\n clean_results_excluding_current_period AS ( select\n    *\nfrom\n    clean_results\nwhere\n    time_key < DATE_TRUNC(:param_time_key, CURRENT_DATE) ),\n forecast AS ( with\n  time_range as (\n     select\n    case\n      when :param_time_key = 'Month'\n      then timestampadd(MONTH,  :units_to_predict, now()) WHEN :param_time_key = 'Day'\n      then timestampadd(DAY, :units_to_predict, now()) WHEN :param_time_key = 'Week'\n      then timestampadd(WEEK, :units_to_predict, now()) WHEN :param_time_key = 'Quarter'\n      then timestampadd(QUARTER, :units_to_predict, now()) WHEN :param_time_key = 'Year'\n      then timestampadd(YEAR, :units_to_predict, now())\n      else timestampadd(MONTH, :units_to_predict, now())\n    end AS end_time, :forecast_toggle AS forecast_toggle ) select\n    *, MIN(time_key) OVER() AS start_time_window, MAX(time_key) OVER() AS end_time_raw, case\n      when UPPER(:param_time_key) = 'DAY'\n      then DATE_ADD(end_time_raw, 0) WHEN UPPER(:param_time_key) = 'WEEK'\n      then DATE_ADD(end_time_raw, 6) WHEN UPPER(:param_time_key) = 'MONTH'\n      then DATE_ADD(DATE_TRUNC('MONTH', ADD_MONTHS(end_time_raw, 1)),\n -1) WHEN UPPER(:param_time_key) = 'QUARTER'\n      then DATE_ADD(DATE_TRUNC('QUARTER', ADD_MONTHS(end_time_raw, 3)),\n -1) WHEN UPPER(:param_time_key) = 'YEAR'\n      then DATE_ADD(DATE_TRUNC('YEAR', ADD_MONTHS(end_time_raw, 12)),\n -1)\n    end AS end_time_window, case\n      when :param_time_key = 'Day'\n      then 24 -- for intraday forecast attribution WHEN :param_time_key = 'Week'\n      then 7 WHEN :param_time_key = 'Month'\n      then DAY(LAST_DAY(time_key)) WHEN :param_time_key = 'Quarter'\n      then 90  -- Approximation WHEN :param_time_key = 'Year'\n      then 365  -- Approximation\n    end AS total_period_units, case\n      when :param_time_key = 'Day'\n      then 24 -- Must do this outside the forecast function WHEN :param_time_key = 'Week'\n      then DATEDIFF(CURRENT_DATE, DATE_TRUNC('WEEK', CURRENT_DATE)) + 1 WHEN :param_time_key = 'Month'\n      then DAY(CURRENT_DATE) WHEN :param_time_key = 'Quarter'\n      then DATEDIFF(CURRENT_DATE, DATE_TRUNC('QUARTER', CURRENT_DATE)) + 1 WHEN :param_time_key = 'Year'\n      then DATEDIFF(CURRENT_DATE, DATE_TRUNC('YEAR', CURRENT_DATE)) + 1\n    end AS completed_period_units\nfrom\n    AI_FORECAST( TABLE (clean_results_excluding_current_period),\n horizon => (select\n    MAX(end_time)\nfrom\n    time_range),\n time_col => 'time_key', value_col => ARRAY('usage_usd_dynamic'),\n prediction_interval_width => 0.9, parameters => '{\"global_floor\": 0}' )\nwhere\n    usage_usd_dynamic_forecast IS NOT NULL ),\n final_forecast AS ( select\n    time_key, :param_time_key AS time_period, usage_usd_dynamic_forecast AS raw_forecast, total_period_units, completed_period_units, case\n      when time_key = DATE_TRUNC(:param_time_key, CURRENT_DATE)\n      then usage_usd_dynamic_forecast * ((total_period_units - completed_period_units) / total_period_units)\n      else usage_usd_dynamic_forecast\n    end AS usage_usd_dynamic_forecast, case\n      when time_key = DATE_TRUNC(:param_time_key, CURRENT_DATE)\n      then usage_usd_dynamic_upper * ((total_period_units - completed_period_units)  / total_period_units)\n      else usage_usd_dynamic_upper\n    end AS usage_usd_dynamic_upper, case\n      when time_key = DATE_TRUNC(:param_time_key, CURRENT_DATE)\n      then usage_usd_dynamic_lower * ((total_period_units - completed_period_units)  / total_period_units)\n      else usage_usd_dynamic_lower\n    end AS usage_usd_dynamic_lower, start_time_window, end_time_window, CONCAT(CAST(start_time_window AS STRING),\n ' to ', CAST(end_time_window AS STRING)) AS time_window_string\nfrom\n    forecast ),\n final_results AS ( select\n    time_key, usage_usd_dynamic, NULL AS upper_forecast, NULL AS lower_forecast, usage_type, :param_time_key AS time_period, max_usage_hour, start_time_window, end_time_window, CONCAT(CAST(start_time_window AS STRING),\n ' to ', CAST(end_time_window AS STRING)) AS time_window_string\nfrom\n    clean_results UNION ALL select\n    -- Intraday extrapolation time_key, usage_usd_dynamic + ((24 - HOUR(max_usage_hour) + 1) * (usage_usd_dynamic / (HOUR(max_usage_hour) + 1))) AS usage_usd_dynamic, NULL AS upper_forecast, NULL AS lower_forecast, 'Forecast', :param_time_key AS time_period, max_usage_hour, (select\n    MAX(start_time_window)\nfrom\n    final_forecast) AS start_time_window, (select\n    MAX(start_time_window)\nfrom\n    final_forecast) AS end_time_window, CONCAT(CAST(start_time_window AS STRING),\n ' to ', CAST(end_time_window AS STRING)) AS time_window_string\nfrom\n    clean_results\nwhere\n    :forecast_toggle = 'Enabled' AND :param_time_key = 'Day' AND time_key = end_time_window -- Add back last day to simulate partial linear extrapolation UNION ALL select\n    time_key, usage_usd_dynamic_forecast AS usage_usd_dynamic, usage_usd_dynamic_upper AS upper_forecast, usage_usd_dynamic_lower AS lower_forecast, 'Forecast' AS usage_type, time_period AS time_period, NULL AS max_usage_hour, start_time_window, end_time_window, CONCAT(CAST(start_time_window AS STRING),\n ' to ', CAST(end_time_window AS STRING)) AS time_window_string\nfrom\n    final_forecast\nwhere\n    case\n      when :forecast_toggle = 'Enabled'\n      then TRUE\n      else FALSE\n    end ) select\n    *, first_value(time_window_string) OVER(ORDER BY time_key DESC) AS forecast_time_window_string\nfrom\n    final_results",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-14d/d to now/d",
        "complexType": "RANGE"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.account_prices"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Day"
      },
      {
        "displayName": "param_group_key",
        "keyword": "param_group_key",
        "dataType": "STRING",
        "defaultValue": "Product"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      },
      {
        "displayName": "units_to_predict",
        "keyword": "units_to_predict",
        "dataType": "DECIMAL",
        "defaultValue": "3"
      },
      {
        "displayName": "forecast_toggle",
        "keyword": "forecast_toggle",
        "dataType": "STRING",
        "defaultValue": "Enabled"
      }
    ]
  },
  {
    "displayName": "usage_overview_pop_matrix",
    "sqlQuery": "SET ansi_mode = true; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace -- Must assume this works to filter\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    *, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = True\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) AND (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) as usage_year, date_trunc('QUARTER', usage_date) as usage_quarter, date_trunc('MONTH', usage_date) as usage_month, date_trunc('WEEK', usage_date) as usage_week, MIN(usage_date) OVER () AS start_time, MAX(usage_date) OVER () AS end_time, u.*\nfrom\n    usage_filtered as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n -- eval time_key param list_priced_usd_with_time_key as ( select\n    identifier ( case\n      when :param_time_key = 'Year'\n      then 'usage_year' when :param_time_key = 'Quarter'\n      then 'usage_quarter' when :param_time_key = 'Month'\n      then 'usage_month' when :param_time_key = 'Week'\n      then 'usage_week' when :param_time_key = 'Day'\n      then 'usage_date'\n      else 'usage_date'\n    end )::date as time_key, *\nfrom\n    list_priced_usd\nwhere\n    (array_contains(:is_serverless, IsServerless) OR array_contains(:is_serverless,'all')) ),\n list_priced_usd_with_time_and_group_keys as ( select\n    workspace as workspace_norm, case\n      when :param_group_key = 'Workspace'\n      then workspace_norm WHEN :param_group_key = 'Product'\n      then billing_origin_product WHEN :param_group_key = 'SKU'\n      then sku_name WHEN :param_group_key = 'Photon'\n      then IsPhoton WHEN :param_group_key = 'Serverless'\n      then IsServerless\n    end AS group_key, *\nfrom\n    list_priced_usd_with_time_key u ),\n -- calc usage by period grouped_usage_by_period as ( select\n    time_key as period_key, replace(replace(group_key, '<', '&lt;'),\n '>', '&gt;') as group_key, -- Make dynamic SUM(case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd END) AS usage_usd\nfrom\n    list_priced_usd_with_time_and_group_keys group by all ),\n -- calc periodic change grouped_usage_change as ( select\n    period_key, group_key, usage_usd, lag(usage_usd, 1) over (partition by group_key order by period_key) as prev_usage_usd, round(try_divide((usage_usd - prev_usage_usd),\n prev_usage_usd) * 100, 2) as usage_change_percentage\nfrom\n    grouped_usage_by_period ),\n total_usage_change as ( select\n    period_key, '<b>TOTAL</b>' as group_key, sum(usage_usd) as usage_usd, lag(sum(usage_usd),\n 1) over (order by period_key) as prev_usage_usd, round(try_divide((sum(usage_usd) - prev_usage_usd),\n prev_usage_usd) * 100, 2) as usage_change_percentage\nfrom\n    grouped_usage_by_period group by period_key ),\n -- periods period_info as ( select\n    case\n      when :param_time_key = 'Day'\n      then :time_range.max::date when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date)\n    end as current_period, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date- interval 1 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 7 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 1 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 3 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 1 year)\n    end as last_period, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 2 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 14 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 2 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 6 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 2 year)\n    end as 2_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 3 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 21 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 3 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 9 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 3 year)\n    end as 3_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 4 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 28 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 4 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 12 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 4 year)\n    end as 4_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 5 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 35 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 5 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 15 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 5 year)\n    end as 5_periods_ago ),\n -- pivot change usage_change_pivot as ( select\n    case\n      when period_key = current_period\n      then 'Current period' when period_key = last_period\n      then 'Last period' when period_key = 2_periods_ago\n      then '2 periods ago' when period_key = 3_periods_ago\n      then '3 periods ago' when period_key = 4_periods_ago\n      then '4 periods ago' when period_key = 5_periods_ago\n      then '5 periods ago'\n    end as x_period_back, group_key, usage_usd, usage_change_percentage\nfrom\n    ( select\n    *\nfrom\n    grouped_usage_change, period_info union all select\n    *\nfrom\n    total_usage_change, period_info ) ),\n -- pivot all time all_time_usage_pivot as ( select\n    'Start to\n    end date' as x_period_back, group_key, sum(usage_usd) as usage_usd, null as usage_change_percentage\nfrom\n    grouped_usage_by_period group by group_key ),\n -- pivot total all time all_time_total_usage_pivot as ( select\n    'Start to\n    end date' as x_period_back, '<b>TOTAL</b>' as group_key, sum(usage_usd) as usage_usd, null as usage_change_percentage\nfrom\n    grouped_usage_by_period ),\n union_usage_pivot as ( select\n    x_period_back, group_key, case\n      when x_period_back = 'Start to\n    end date'\n      then string(usage_usd)\n      else concat('<span style=\"zoom:1\">', usage_usd_str, '</span><span style=\"zoom:1;color:', change_color, '\">&nbsp;', usage_change_str, '</span>')\n    end as usage_info\nfrom\n    ( select\n    case\n      when usage_usd >= 1e9\n      then concat(format_number(usage_usd / 1e9, 0),\n 'B') when usage_usd >= 1e6\n      then concat(format_number(usage_usd / 1e6, 0),\n 'M') when usage_usd >= 1e3\n      then concat(format_number(usage_usd / 1e3, 0),\n 'K')\n      else format_number(usage_usd, 0)\n    end as usage_usd_str, case\n      when usage_change_percentage > 10\n      then '#00A972' when usage_change_percentage < -10\n      then '#FF3621'\n      else '#919191'\n    end as _change_color, concat('(', if(usage_change_percentage > 0, '+', ''),\n format_number(usage_change_percentage, 0),\n '%)') as _usage_change_str, coalesce(_change_color, '#919191') as change_color, coalesce(_usage_change_str, '') as usage_change_str, *\nfrom\n    ( select\n    x_period_back, group_key, usage_usd, usage_change_percentage\nfrom\n    usage_change_pivot union all select\n    *\nfrom\n    all_time_usage_pivot union all select\n    *\nfrom\n    all_time_total_usage_pivot ) ) ),\n pre_format_results AS ( -- query select\n    group_key, case\n      when :usage_toggle = 'Dollars'\n      then concat('$', format_number(float(`Start to\n    end date`),\n 0)) WHEN :usage_toggle = 'DBUs'\n      then concat('', format_number(float(`Start to\n    end date`),\n 0))\n    end as `Start to\n    end date`, float(`Start to\n    end date`) as _all_time_usage_usd, 2 as _order, coalesce(`5 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `5 periods ago`, coalesce(`4 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `4 periods ago`, coalesce(`3 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `3 periods ago`, coalesce(`2 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `2 periods ago`, coalesce(`Last period`, '<span style=\"zoom:1;color:#919191\">0</span>') as `Last period`, coalesce(`Current period`, '<span style=\"zoom:1;color:#919191\">0</span>') as `Current period`\nfrom\n    union_usage_pivot pivot ( first(usage_info) for x_period_back in ( 'Start to\n    end date', '5 periods ago', '4 periods ago', '3 periods ago', '2 periods ago', 'Last period', 'Current period' ) ) union all ( select\n    '' as group_key, concat('<b><i>', date_format(:time_range.min, 'MMM dd yyyy'),\n ' - ', date_format(:time_range.max, 'MMM dd yyyy'),\n '</i></b>') as `Start to\n    end date`, null as _all_time_usage_usd, 1 as _order, concat('<b><i>', date_format(5_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(4_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `5 periods ago`, concat('<b><i>', date_format(4_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(3_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `4 periods ago`, concat('<b><i>', date_format(3_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(2_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `3 periods ago`, concat('<b><i>', date_format(2_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(last_period, -1),\n 'MMM dd'),\n '</i></b>') as `2 periods ago`, concat('<b><i>', date_format(last_period, 'MMM dd'),\n ' - ', date_format(date_add(current_period, -1),\n 'MMM dd'),\n '</i></b>') as `Last period`, concat('<b><i>', date_format(current_period, 'MMM dd'),\n ' -\n    end Time', '</i></b>') as `Current period`\nfrom\n    period_info ) ) select\n    *, MAX(_all_time_usage_usd) OVER() AS max_usage, MIN(_all_time_usage_usd) OVER() AS min_usage, -- add data bars COALESCE(CONCAT( '<div style=\"position: relative; height: 20px; border-radius: 4px; overflow: hidden;\">', '<div style=\"position: absolute; width: ', ROUND(try_divide((_all_time_usage_usd - min_usage),\n NULLIF(max_usage - min_usage, 0)) * 100, 2),\n '%; height: 100%; background: #077A9D; border-radius: 4px;\"></div>', '<span style=\"position: absolute; width: 100%; text-align: center; line-height: 20px; font-weight: bold; color: #00A972;\">', case\n      when :usage_toggle = 'Dollars'\n      then '$'\n      else '' END, FORMAT_NUMBER(_all_time_usage_usd, 0),\n '</span></div>' ),\n `Start to\n    end date`) AS usage_bar_html\nfrom\n    pre_format_results order by _order asc, _all_time_usage_usd desc",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Month"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "param_group_key",
        "keyword": "param_group_key",
        "dataType": "STRING",
        "defaultValue": "Product"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.list_prices"
      }
    ]
  },
  {
    "displayName": "tag_analysis_top_tags",
    "sqlQuery": "SET ansi_mode = true; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace -- Must assume this works to filter\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    *, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = True\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) AND (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) as usage_year, date_trunc('QUARTER', usage_date) as usage_quarter, date_trunc('MONTH', usage_date) as usage_month, date_trunc('WEEK', usage_date) as usage_week, MIN(usage_date) OVER () AS start_time, MAX(usage_date) OVER () AS end_time, u.*\nfrom\n    usage_filtered as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n exploded_usage_tags_to_compare AS ( select\n    record_id, identifier ( case\n      when :param_time_key = 'Year'\n      then 'usage_year' when :param_time_key = 'Quarter'\n      then 'usage_quarter' when :param_time_key = 'Month'\n      then 'usage_month' when :param_time_key = 'Week'\n      then 'usage_week' when :param_time_key = 'Day'\n      then 'usage_date'\n      else 'usage_date'\n    end )::date as time_key, case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd\n    end AS usage_usd, workspace, IsServerless, IsPhoton, billing_origin_product, explode(custom_tags)\nfrom\n    list_priced_usd AS u ),\n pre_filter AS ( select\n    case\n      when :top_tag_aggregate_by = 'Keys'\n      then case\n      when :normalize_case = 'Yes'\n      then trim(lower(key))\n      else key\n    end WHEN :top_tag_aggregate_by = 'Key-Value Pairs'\n      then case\n      when :normalize_case = 'Yes'\n      then CONCAT(COALESCE(lower(trim(key)),\n ''),\n '=', COALESCE(lower(trim(value)),\n ''))\n    end WHEN :top_tag_aggregate_by = 'Values'\n      then case\n      when :normalize_case = 'Yes'\n      then trim(lower(value))\n      else value\n    end END AS dynamic_tag_rollup, workspace, time_key, IsServerless, IsPhoton, billing_origin_product, SUM(usage_usd) AS usage_usd\nfrom\n    exploded_usage_tags_to_compare GROUP BY ALL ),\n tag_rank AS ( select\n    dynamic_tag_rollup, SUM(usage_usd) AS usage_usd, ROW_NUMBER() OVER(ORDER BY SUM(usage_usd) DESC) AS tag_rank_number\nfrom\n    pre_filter GROUP BY dynamic_tag_rollup ) select\n    p.*, tag_rank_number\nfrom\n    pre_filter p\n  INNER join\n    tag_rank tr\n    on p.dynamic_tag_rollup = tr.dynamic_tag_rollup\nwhere\n    tag_rank_number <= :top_n_tags",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "top_tag_aggregate_by",
        "keyword": "top_tag_aggregate_by",
        "dataType": "STRING",
        "defaultValue": "Keys"
      },
      {
        "displayName": "top_n_tags",
        "keyword": "top_n_tags",
        "dataType": "DECIMAL",
        "defaultValue": "10"
      },
      {
        "displayName": "normalize_case",
        "keyword": "normalize_case",
        "dataType": "STRING",
        "defaultValue": "Yes"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Month"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.list_prices"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      }
    ]
  },
  {
    "displayName": "tag_analysis_summary",
    "sqlQuery": "SET ansi_mode = true; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace -- Must assume this works to filter\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    *, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = True\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) AND (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) as usage_year, date_trunc('QUARTER', usage_date) as usage_quarter, date_trunc('MONTH', usage_date) as usage_month, date_trunc('WEEK', usage_date) as usage_week, MIN(usage_date) OVER () AS start_time, MAX(usage_date) OVER () AS end_time, u.*\nfrom\n    usage_filtered as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n -- eval time_key param list_priced_usd_with_time_key as ( select\n    identifier ( case\n      when :param_time_key = 'Year'\n      then 'usage_year' when :param_time_key = 'Quarter'\n      then 'usage_quarter' when :param_time_key = 'Month'\n      then 'usage_month' when :param_time_key = 'Week'\n      then 'usage_week' when :param_time_key = 'Day'\n      then 'usage_date'\n      else 'usage_date'\n    end )::date as time_key, *\nfrom\n    list_priced_usd ),\n tag_entry_parsing AS ( select\n    tag_entry, contains(tag_entry, '=') AS is_filter, IF(contains(tag_entry, '='),\n split(tag_entry, '=')[0], tag_entry) AS tag_key, ROW_NUMBER() OVER (ORDER BY tag_entry) AS tag_id\nfrom\n    ( select\n    explode(split(:param_tag_entries, ';')) AS tag_entry\nfrom\n    VALUES(1) AS dummy(x) ) ),\n exploded_usage_tags_to_compare AS ( select\n    record_id, explode(custom_tags),\n custom_tags\nfrom\n    usage_filtered AS u ),\n matched_records AS (select\n    record_id, -- array of maps that match array_distinct(array_agg(case\n      when tag_id IS NOT NULL\n      then concat(spine.key, '=', spine.value) END)) AS matched_tags_array, array_distinct(array_agg(concat(spine.key, '=', spine.value))) AS usage_tags_array, -- Add keys only agg view array_distinct(array_agg(case\n      when tag_id IS NOT NULL\n      then spine.key END)) AS matched_keys_array, array_distinct(array_agg(spine.key)) AS usage_keys_array, -- size(matched_tags_array) AS matched_tag_count, (select\n    COUNT (0)\nfrom\n    tag_entry_parsing\nwhere\n    length(tag_entry) > 0) AS search_tag_count, if(search_tag_count = 0 OR (case\n      when :tag_search_mode = \"AND\"\n      then search_tag_count <= matched_tag_count WHEN :tag_search_mode = \"OR\"\n      then matched_tag_count > 0 END),\n -- Add key aggregation option case\n      when :group_agg_mode = 'Key-Value Pairs'\n      then array_join(array_distinct(matched_tags_array),\n ';') WHEN :group_agg_mode = 'Keys'\n      then array_join(array_distinct(matched_keys_array),\n ';')\n    end , '' )  as _custom_tag_key_value_pairs, if(_custom_tag_key_value_pairs = \"\", '<NO TAG MATCH>', _custom_tag_key_value_pairs) as custom_tag_key_value_pairs, -- Is match yes/no if (search_tag_count = 0 OR (case\n      when :tag_search_mode = \"AND\"\n      then search_tag_count <= matched_tag_count WHEN :tag_search_mode = \"OR\"\n      then matched_tag_count > 0 END),\n '<TAG MATCH>', '<NO TAG MATCH>') AS IsMatched\nfrom\n    exploded_usage_tags_to_compare AS spine\n  LEFT join\n    tag_entry_parsing AS tt\n    on (case\n      when :normalize_case = 'Yes'\n      then (-- Join\n    on Key only if is_filter = false (trim(lower(tt.tag_key)) = trim(lower(spine.key)) AND tt.is_filter = false) OR (trim(lower(tt.tag_entry)) = concat(trim(lower(spine.key)),\n '=', trim(lower(spine.value))) AND tt.is_filter = true) )\n      else (-- Join\n    on Key only if is_filter = true (tt.tag_key = spine.key AND tt.is_filter = false) OR (tt.tag_entry = concat(spine.key, '=', spine.value) AND tt.is_filter = true) )\n    end ) GROUP BY record_id ),\n -- match tag entries list_priced_usd_with_matching_tag_kvp as ( select\n    mt._custom_tag_key_value_pairs, COALESCE(mt.custom_tag_key_value_pairs, '<NOT TAGGED>') AS custom_tag_key_value_pairs, -- There are matched tag records,\n      then records with tags that dont match the ask,\n      then totally untagged resources COALESCE(IsMatched, '<NOT TAGGED>') AS IsMatchedClean, array_distinct(mt.matched_tags_array) AS kvp, k.*\nfrom\n    list_priced_usd_with_time_key k\n  left join\n    matched_records as mt\n    on k.record_id = mt.record_id ),\n pre_ui_results AS ( -- query select\n    time_key, IsServerless, IsPhoton, workspace AS workspace_id, billing_origin_product, sku_name, IsMatchedClean, case\n      when custom_tag_key_value_pairs IN ('<NO TAG MATCH>', '<NOT TAGGED>') OR :normalize_case = 'No'\n      then custom_tag_key_value_pairs\n      else lower(custom_tag_key_value_pairs)\n    end AS custom_tag_key_value_pairs, -- Make dynamic case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd\n    end AS usage_usd, kvp\nfrom\n    list_priced_usd_with_matching_tag_kvp\nwhere\n    ( case\n      when :param_show_tag_mismatch = 'All Usage'\n      then True WHEN :param_show_tag_mismatch = 'Not Matched Only'\n      then custom_tag_key_value_pairs IN ('<NO TAG MATCH>', '<NOT TAGGED>') WHEN :param_show_tag_mismatch = 'Matched Only'\n      then custom_tag_key_value_pairs NOT IN ('<NO TAG MATCH>', '<NOT TAGGED>')\n    end ) ) select\n    case\n      when :tag_group = 'Workspace'\n      then workspace_id WHEN :tag_group = 'Product'\n      then billing_origin_product WHEN :tag_group = 'SKU'\n      then sku_name WHEN :tag_group = 'Matched Status'\n      then IsMatchedClean WHEN :tag_group = 'Tag Key-Value Pairs'\n      then custom_tag_key_value_pairs WHEN :tag_group = 'Photon'\n      then IsPhoton WHEN :tag_group = 'Serverless'\n      then IsServerless\n    end AS group_key, case\n      when IsMatchedClean = '<TAG MATCH>'\n      then usage_usd\n      else 0\n    end AS Measure_MatchedUsage, *\nfrom\n    pre_ui_results",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.list_prices"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Month"
      },
      {
        "displayName": "param_tag_entries",
        "keyword": "param_tag_entries",
        "dataType": "STRING",
        "defaultValue": "Budget;Env"
      },
      {
        "displayName": "normalize_case",
        "keyword": "normalize_case",
        "dataType": "STRING",
        "defaultValue": "Yes"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      },
      {
        "displayName": "param_show_tag_mismatch",
        "keyword": "param_show_tag_mismatch",
        "dataType": "STRING",
        "defaultValue": "All Usage"
      },
      {
        "displayName": "tag_group",
        "keyword": "tag_group",
        "dataType": "STRING",
        "defaultValue": "Tag Key-Value Pairs"
      },
      {
        "displayName": "tag_search_mode",
        "keyword": "tag_search_mode",
        "dataType": "STRING",
        "defaultValue": "AND"
      },
      {
        "displayName": "group_agg_mode",
        "keyword": "group_agg_mode",
        "dataType": "STRING",
        "defaultValue": "Key-Value Pairs"
      }
    ]
  },
  {
    "displayName": "tag_analysis_pop_matrix",
    "sqlQuery": "SET ansi_mode = True; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace -- Must assume this works to filter\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    *, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = True\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) AND (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) as usage_year, date_trunc('QUARTER', usage_date) as usage_quarter, date_trunc('MONTH', usage_date) as usage_month, date_trunc('WEEK', usage_date) as usage_week, MIN(usage_date) OVER () AS start_time, MAX(usage_date) OVER () AS end_time, u.*\nfrom\n    usage_filtered as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n -- eval time_key param list_priced_usd_with_time_key as ( select\n    identifier ( case\n      when :param_time_key = 'Year'\n      then 'usage_year' when :param_time_key = 'Quarter'\n      then 'usage_quarter' when :param_time_key = 'Month'\n      then 'usage_month' when :param_time_key = 'Week'\n      then 'usage_week' when :param_time_key = 'Day'\n      then 'usage_date'\n      else 'usage_date'\n    end )::date as time_key, *\nfrom\n    list_priced_usd ),\n tag_entry_parsing AS ( select\n    tag_entry, contains(tag_entry, '=') AS is_filter, IF(contains(tag_entry, '='),\n split(tag_entry, '=')[0], tag_entry) AS tag_key, ROW_NUMBER() OVER (ORDER BY tag_entry) AS tag_id\nfrom\n    ( select\n    explode(split(:param_tag_entries, ';')) AS tag_entry\nfrom\n    VALUES(1) AS dummy(x) ) ),\n exploded_usage_tags_to_compare AS ( select\n    record_id, explode(custom_tags),\n custom_tags\nfrom\n    usage_filtered AS u ),\n matched_records AS (select\n    record_id, -- array of maps that match array_distinct(array_agg(case\n      when tag_id IS NOT NULL\n      then concat(spine.key, '=', spine.value) END)) AS matched_tags_array, array_distinct(array_agg(concat(spine.key, '=', spine.value))) AS usage_tags_array, -- Add keys only agg view array_distinct(array_agg(case\n      when tag_id IS NOT NULL\n      then spine.key END)) AS matched_keys_array, array_distinct(array_agg(spine.key)) AS usage_keys_array, -- size(matched_tags_array) AS matched_tag_count, (select\n    COUNT (0)\nfrom\n    tag_entry_parsing\nwhere\n    length(tag_entry) > 0) AS search_tag_count, if(search_tag_count = 0 OR (case\n      when :tag_search_mode = \"AND\"\n      then search_tag_count <= matched_tag_count WHEN :tag_search_mode = \"OR\"\n      then matched_tag_count > 0 END),\n -- Add key aggregation option case\n      when :group_agg_mode = 'Key-Value Pairs'\n      then array_join(array_distinct(matched_tags_array),\n ';') WHEN :group_agg_mode = 'Keys'\n      then array_join(array_distinct(matched_keys_array),\n ';')\n    end , '' )  as _custom_tag_key_value_pairs, if(_custom_tag_key_value_pairs = \"\", '&lt;NO TAG MATCH&gt;', _custom_tag_key_value_pairs) as custom_tag_key_value_pairs, -- Is match yes/no if (search_tag_count = 0 OR (case\n      when :tag_search_mode = \"AND\"\n      then search_tag_count <= matched_tag_count WHEN :tag_search_mode = \"OR\"\n      then matched_tag_count > 0 END),\n '&lt;TAG MATCH&gt;', '&lt;NO TAG MATCH&gt;') AS IsMatched\nfrom\n    exploded_usage_tags_to_compare AS spine\n  LEFT join\n    tag_entry_parsing AS tt\n    on (case\n      when :normalize_case = 'Yes'\n      then (-- Join\n    on Key only if is_filter = false (trim(lower(tt.tag_key)) = trim(lower(spine.key)) AND tt.is_filter = false) OR (trim(lower(tt.tag_entry)) = concat(trim(lower(spine.key)),\n '=', trim(lower(spine.value))) AND tt.is_filter = true) )\n      else (-- Join\n    on Key only if is_filter = true (tt.tag_key = spine.key AND tt.is_filter = false) OR (tt.tag_entry = concat(spine.key, '=', spine.value) AND tt.is_filter = true) )\n    end ) GROUP BY record_id ),\n -- match tag entries list_priced_usd_with_matching_tag_kvp as ( select\n    mt._custom_tag_key_value_pairs, COALESCE(mt.custom_tag_key_value_pairs, '&lt;NOT TAGGED&gt;') AS custom_tag_key_value_pairs, -- There are matched tag records,\n      then records with tags that dont match the ask,\n      then totally untagged resources COALESCE(IsMatched, '&lt;NOT TAGGED&gt;') AS IsMatchedClean, mt.matched_tags_array AS kvp, k.*\nfrom\n    list_priced_usd_with_time_key k\n  left join\n    matched_records as mt\n    on k.record_id = mt.record_id\nwhere\n    (case\n      when :param_show_tag_mismatch = 'All Usage'\n      then True WHEN :param_show_tag_mismatch = 'Not Matched Only'\n      then COALESCE(mt.custom_tag_key_value_pairs, '&lt;NOT TAGGED&gt;') IN ('&lt;NO TAG MATCH&gt;', '&lt;NOT TAGGED&gt;') WHEN :param_show_tag_mismatch = 'Matched Only'\n      then COALESCE(mt.custom_tag_key_value_pairs, '&lt;NOT TAGGED&gt;') NOT IN ('&lt;NO TAG MATCH&gt;', '&lt;NOT TAGGED&gt;') END) ),\n total_match_percent AS ( select\n    sum(if(custom_tag_key_value_pairs NOT IN ('&lt;NO TAG MATCH&gt;', '&lt;NOT TAGGED&gt;'),\n    -- Make dynamic case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd END, 0)) as match_usage_usd, sum(   -- Make dynamic case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd END) as total_usage_usd, round(try_divide(match_usage_usd , total_usage_usd),\n 3) as tag_match_percentage\nfrom\n    list_priced_usd_with_matching_tag_kvp ),\n -- calc usage by period grouped_usage_by_period as ( select\n    time_key as period_key, case\n      when :tag_group = 'Workspace'\n      then workspace WHEN :tag_group = 'Product'\n      then billing_origin_product WHEN :tag_group = 'SKU'\n      then sku_name WHEN :tag_group = 'Matched Status'\n      then IsMatchedClean WHEN :tag_group = 'Tag Key-Value Pairs'\n      then custom_tag_key_value_pairs WHEN :tag_group = 'Photon'\n      then IsPhoton WHEN :tag_group = 'Serverless'\n      then IsServerless\n    end AS group_key, -- Make results aggregation optionally case sensitive sum(   -- Make dynamic case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd END) as usage_usd\nfrom\n    list_priced_usd_with_matching_tag_kvp group by all ),\n -- calc periodic change grouped_usage_change as ( select\n    period_key, group_key, usage_usd, lag(usage_usd, 1) over (partition by group_key order by period_key) as prev_usage_usd, round(try_divide((usage_usd - prev_usage_usd),\n prev_usage_usd) * 100, 2) as usage_change_percentage\nfrom\n    grouped_usage_by_period ),\n total_usage_change as ( select\n    period_key, '<b>TOTAL</b>' as group_key, sum(usage_usd) as usage_usd, lag(sum(usage_usd),\n 1) over (order by period_key) as prev_usage_usd, round(try_divide((sum(usage_usd) - prev_usage_usd),\n prev_usage_usd) * 100, 2) as usage_change_percentage\nfrom\n    grouped_usage_by_period group by period_key ),\n -- periods period_info as ( select\n    case\n      when :param_time_key = 'Day'\n      then :time_range.max::date when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date)\n    end as current_period, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date- interval 1 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 7 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 1 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 3 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 1 year)\n    end as last_period, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 2 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 14 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 2 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 6 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 2 year)\n    end as 2_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 3 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 21 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 3 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 9 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 3 year)\n    end as 3_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 4 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 28 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 4 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 12 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 4 year)\n    end as 4_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 5 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 35 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 5 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 15 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 5 year)\n    end as 5_periods_ago ),\n -- pivot change usage_change_pivot as ( select\n    case\n      when period_key = current_period\n      then 'Current period' when period_key = last_period\n      then 'Last period' when period_key = 2_periods_ago\n      then '2 periods ago' when period_key = 3_periods_ago\n      then '3 periods ago' when period_key = 4_periods_ago\n      then '4 periods ago' when period_key = 5_periods_ago\n      then '5 periods ago'\n    end as x_period_back, group_key, usage_usd, usage_change_percentage\nfrom\n    ( select\n    *\nfrom\n    grouped_usage_change, period_info union all select\n    *\nfrom\n    total_usage_change, period_info ) ),\n -- pivot all time all_time_usage_pivot as ( select\n    'Start to\n    end date' as x_period_back, group_key, sum(usage_usd) as usage_usd, null as usage_change_percentage\nfrom\n    grouped_usage_by_period group by group_key ),\n -- pivot total all time all_time_total_usage_pivot as ( select\n    'Start to\n    end date' as x_period_back, '<b>TOTAL</b>' as group_key, sum(usage_usd) as usage_usd, null as usage_change_percentage\nfrom\n    grouped_usage_by_period ),\n union_usage_pivot as ( select\n    x_period_back, group_key, case\n      when x_period_back = 'Start to\n    end date'\n      then string(usage_usd)\n      else concat('<span style=\"zoom:1\">', usage_usd_str, '</span><span style=\"zoom:1;color:', change_color, '\">&nbsp;', usage_change_str, '</span>')\n    end as usage_info\nfrom\n    ( select\n    case\n      when usage_usd >= 1e9\n      then concat(format_number(usage_usd / 1e9, 0),\n 'B') when usage_usd >= 1e6\n      then concat(format_number(usage_usd / 1e6, 0),\n 'M') when usage_usd >= 1e3\n      then concat(format_number(usage_usd / 1e3, 0),\n 'K')\n      else format_number(usage_usd, 0)\n    end as usage_usd_str, case\n      when usage_change_percentage > 10\n      then '#00A972' when usage_change_percentage < -10\n      then '#FF3621'\n      else '#919191'\n    end as _change_color, concat('(', if(usage_change_percentage > 0, '+', ''),\n format_number(usage_change_percentage, 0),\n '%)') as _usage_change_str, coalesce(_change_color, '#919191') as change_color, coalesce(_usage_change_str, '') as usage_change_str, *\nfrom\n    ( select\n    x_period_back, group_key, usage_usd, usage_change_percentage\nfrom\n    usage_change_pivot union all select\n    *\nfrom\n    all_time_usage_pivot union all select\n    *\nfrom\n    all_time_total_usage_pivot ) ) ),\n -- query results_pre_format AS ( select\n    case\n      when group_key IN ('&lt;NOT TAGGED&gt;', '&lt;NO TAG MATCH&gt;', '&lt;TAG MATCH&gt;', '<b>TOTAL</b>') OR :normalize_case = 'No'\n      then group_key\n      else lower(group_key)\n    end AS group_key, case\n      when :usage_toggle = 'Dollars'\n      then concat('$', format_number(float(`Start to\n    end date`),\n 0)) WHEN :usage_toggle = 'DBUs'\n      then concat('', format_number(float(`Start to\n    end date`),\n 0))\n    end as `Start to\n    end date`, float(`Start to\n    end date`) as _all_time_usage_usd, 2 as _order, coalesce(`5 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `5 periods ago`, coalesce(`4 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `4 periods ago`, coalesce(`3 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `3 periods ago`, coalesce(`2 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `2 periods ago`, coalesce(`Last period`, '<span style=\"zoom:1;color:#919191\">0</span>') as `Last period`, coalesce(`Current period`, '<span style=\"zoom:1;color:#919191\">0</span>') as `Current period`\nfrom\n    union_usage_pivot pivot ( first(usage_info) for x_period_back in ( 'Start to\n    end date', '5 periods ago', '4 periods ago', '3 periods ago', '2 periods ago', 'Last period', 'Current period' ) ) union all ( select\n    CONCAT('  ', round((select\n    MAX(tag_match_percentage)\nfrom\n    total_match_percent)*100, 2)::string,'% of usage matching tag search') as group_key, -- This is the formatted total matching percent across tags concat('<b><i>', date_format(:time_range.min, 'MMM dd yyyy'),\n ' - ', date_format(:time_range.max, 'MMM dd yyyy'),\n '</i></b>') as `Start to\n    end date`, null as _all_time_usage_usd, 1 as _order, concat('<b><i>', date_format(5_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(4_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `5 periods ago`, concat('<b><i>', date_format(4_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(3_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `4 periods ago`, concat('<b><i>', date_format(3_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(2_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `3 periods ago`, concat('<b><i>', date_format(2_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(last_period, -1),\n 'MMM dd'),\n '</i></b>') as `2 periods ago`, concat('<b><i>', date_format(last_period, 'MMM dd'),\n ' - ', date_format(date_add(current_period, -1),\n 'MMM dd'),\n '</i></b>') as `Last period`, concat('<b><i>', date_format(current_period, 'MMM dd'),\n ' -\n    end Time', '</i></b>') as `Current period`\nfrom\n    period_info ) ) select\n    *, CONCAT( '<span style=\"color:', case\n      when _order = 1\n      then '#077A9D' WHEN group_key = '&lt;NOT TAGGED&gt;'\n      then '#919191' WHEN group_key = '&lt;NO TAG MATCH&gt;'\n      then '#AB4057' WHEN group_key = '&lt;TAG MATCH&gt;'\n      then '#00A972'\n      else 'inherit' END, case\n      when group_key IN ('&lt;NOT TAGGED&gt;', '&lt;NO TAG MATCH&gt;', '&lt;TAG MATCH&gt;')\n      then '; font-weight: bold' WHEN _order = 1\n      then '; font-weight: bold; font-size: 24px'\n      else '' END, ';\">', group_key, '</span>' ) AS group_key_html, MAX(_all_time_usage_usd) OVER() AS max_usage, MIN(_all_time_usage_usd) OVER() AS min_usage, COALESCE(CONCAT( '<div style=\"position: relative; height: 20px; border-radius: 4px; overflow: hidden;\">', '<div style=\"position: absolute; width: ', ROUND(try_divide((_all_time_usage_usd - min_usage),\n NULLIF(max_usage - min_usage, 0))* 100, 2),\n '%; height: 100%; background: #077A9D; border-radius: 4px;\"></div>', '<span style=\"position: absolute; width: 100%; text-align: center; line-height: 20px; font-weight: bold; color: #00A972;\">', case\n      when :usage_toggle = 'Dollars'\n      then '$'\n      else '' END, FORMAT_NUMBER(_all_time_usage_usd, 0),\n '</span></div>' ),\n `Start to\n    end date`) AS usage_bar_html\nfrom\n    results_pre_format order by _order asc, _all_time_usage_usd desc;",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Month"
      },
      {
        "displayName": "param_tag_entries",
        "keyword": "param_tag_entries",
        "dataType": "STRING",
        "defaultValue": "budgetpolicyname;budgetpolicyid"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "group_agg_mode",
        "keyword": "group_agg_mode",
        "dataType": "STRING",
        "defaultValue": "Key-Value Pairs"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.list_prices"
      },
      {
        "displayName": "tag_search_mode",
        "keyword": "tag_search_mode",
        "dataType": "STRING",
        "defaultValue": "AND"
      },
      {
        "displayName": "normalize_case",
        "keyword": "normalize_case",
        "dataType": "STRING",
        "defaultValue": "Yes"
      },
      {
        "displayName": "param_show_tag_mismatch",
        "keyword": "param_show_tag_mismatch",
        "dataType": "STRING",
        "defaultValue": "All Usage"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      },
      {
        "displayName": "tag_group",
        "keyword": "tag_group",
        "dataType": "STRING",
        "defaultValue": "Tag Key-Value Pairs"
      }
    ]
  },
  {
    "displayName": "tag_analysis_match_details",
    "sqlQuery": "SET ansi_mode = True; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, workspace_name, workspace_url, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n usage_filtered as ( select\n    *, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = True\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) AND -- Serverless Filter (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) as usage_year, date_trunc('QUARTER', usage_date) as usage_quarter, date_trunc('MONTH', usage_date) as usage_month, date_trunc('WEEK', usage_date) as usage_week, u.*, COALESCE( (select\n    /*+ BROADCAST(ce) */ MAX(clean_room_name)\nfrom\n    system.access.clean_room_events ce\nwhere\n    ce.central_clean_room_id = usage_metadata.central_clean_room_id),\n (select\n    /*+ BROADCAST(se) */ MAX(endpoint_name)\nfrom\n    system.serving.served_entities se\nwhere\n    se.workspace_id = workspace_id AND se.endpoint_id = usage_metadata.endpoint_id) ) AS asset_name\nfrom\n    usage_filtered as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n -- eval time_key param list_priced_usd_with_time_key as ( select\n    usage_date as time_key, *\nfrom\n    list_priced_usd ),\n tag_entry_parsing AS ( select\n    tag_entry, contains(tag_entry, '=') AS is_filter, IF(contains(tag_entry, '='),\n split(tag_entry, '=')[0], tag_entry) AS tag_key, ROW_NUMBER() OVER (ORDER BY tag_entry) AS tag_id\nfrom\n    ( select\n    explode(split(:param_tag_entries, ';')) AS tag_entry\nfrom\n    VALUES(1) AS dummy(x) ) ),\n exploded_usage_tags_to_compare AS ( select\n    record_id, explode(custom_tags),\n custom_tags\nfrom\n    usage_filtered AS u ),\n matched_records AS (select\n    record_id, -- array of maps that match array_distinct(array_agg(case\n      when tag_id IS NOT NULL\n      then concat(spine.key, '=', spine.value) END)) AS matched_tags_array, array_distinct(array_agg(concat(spine.key, '=', spine.value))) AS usage_tags_array, -- Add keys only agg view array_distinct(array_agg(case\n      when tag_id IS NOT NULL\n      then spine.key END)) AS matched_keys_array, array_distinct(array_agg(spine.key)) AS usage_keys_array, -- size(matched_tags_array) AS matched_tag_count, (select\n    COUNT (0)\nfrom\n    tag_entry_parsing\nwhere\n    length(tag_entry) > 0) AS search_tag_count, if(search_tag_count = 0 OR (case\n      when :tag_search_mode = \"AND\"\n      then search_tag_count <= matched_tag_count WHEN :tag_search_mode = \"OR\"\n      then matched_tag_count > 0 END),\n -- Add key aggregation option case\n      when :group_agg_mode = 'Key-Value Pairs'\n      then array_join(array_distinct(matched_tags_array),\n ';') WHEN :group_agg_mode = 'Keys'\n      then array_join(array_distinct(matched_keys_array),\n ';')\n    end , '' )  as _custom_tag_key_value_pairs, if(_custom_tag_key_value_pairs = \"\", '<NO TAG MATCH>', _custom_tag_key_value_pairs) as custom_tag_key_value_pairs, -- Is match yes/no if (search_tag_count = 0 OR (case\n      when :tag_search_mode = \"AND\"\n      then search_tag_count <= matched_tag_count WHEN :tag_search_mode = \"OR\"\n      then matched_tag_count > 0 END),\n '<TAG MATCH>', '<NO TAG MATCH>') AS IsMatched\nfrom\n    exploded_usage_tags_to_compare AS spine\n  LEFT join\n    tag_entry_parsing AS tt\n    on (case\n      when :normalize_case = 'Yes'\n      then (-- Join\n    on Key only if is_filter = false (trim(lower(tt.tag_key)) = trim(lower(spine.key)) AND tt.is_filter = false) OR (trim(lower(tt.tag_entry)) = concat(trim(lower(spine.key)),\n '=', trim(lower(spine.value))) AND tt.is_filter = true) )\n      else (-- Join\n    on Key only if is_filter = true (tt.tag_key = spine.key AND tt.is_filter = false) OR (tt.tag_entry = concat(spine.key, '=', spine.value) AND tt.is_filter = true) )\n    end ) GROUP BY record_id ),\n -- match tag entries list_priced_usd_with_matching_tag_kvp as ( select\n    mt._custom_tag_key_value_pairs, COALESCE(IsMatched, '<NOT TAGGED>') AS IsMatched, COALESCE(mt.custom_tag_key_value_pairs, '<NOT TAGGED>') AS custom_tag_key_value_pairs, -- There are matched tag records,\n      then records with tags that dont match the ask,\n      then totally untagged resources mt.matched_tags_array AS kvp, k.*, usage_metadata.job_id AS job_id, usage_metadata.cluster_id AS cluster_id, usage_metadata.dlt_pipeline_id AS dlt_pipeline_id, usage_metadata.warehouse_id AS warehouse_id\nfrom\n    list_priced_usd_with_time_key k\n  left join\n    matched_records as mt\n    on k.record_id = mt.record_id ),\n -- Dim tables to get names, deleted, and owner clusters AS ( select\n    /*+ REPARTITION(2, cluster_id) */ workspace_id, cluster_id, cluster_name AS object_name, owned_by AS object_owner, case\n      when delete_time IS NOT NULL\n      then 1\n      else 0\n    end AS is_deleted\nfrom\n    system.compute.clusters QUALIFY ROW_NUMBER() OVER (PARTITION BY workspace_id, cluster_id ORDER BY change_time DESC) = 1 --CLUSTER BY cluster_id ),\n jobs AS ( select\n    /*+ REPARTITION(2, job_id) */ workspace_id, job_id, name AS object_name, '' AS object_owner, case\n      when delete_time IS NOT NULL\n      then 1\n      else 0\n    end AS is_deleted\nfrom\n    system.lakeflow.jobs QUALIFY ROW_NUMBER() OVER (PARTITION BY workspace_id, job_id ORDER BY change_time DESC) = 1 --CLUSTER BY job_id ),\n pipelines AS ( select\n    /*+ REPARTITION(2, pipeline_id) */ workspace_id, pipeline_id, name AS object_name, COALESCE(run_as, created_by) AS object_owner, case\n      when delete_time IS NOT NULL\n      then 1\n      else 0\n    end AS is_deleted\nfrom\n    system.lakeflow.pipelines QUALIFY ROW_NUMBER() OVER (PARTITION BY workspace_id, pipeline_id ORDER BY change_time DESC) = 1 -- CLUSTER BY pipeline_id ),\n warehouses AS ( select\n    /*+ REPARTITION(2, warehouse_id) */ workspace_id, warehouse_id, warehouse_name AS object_name, '' AS object_owner, case\n      when delete_time IS NOT NULL\n      then 1\n      else 0\n    end AS is_deleted\nfrom\n    system.compute.warehouses QUALIFY ROW_NUMBER() OVER (PARTITION BY workspace_id, warehouse_id ORDER BY change_time DESC) = 1 --CLUSTER BY warehouse_id ),\n pre_results AS ( select\n    /*+ BROADCAST(j),\n BROADCAST(c),\n BROADCAST(p),\n BROADCAST(w) */ coalesce(identity_metadata.run_as, identity_metadata.owned_by, identity_metadata.created_by, j.object_owner, c.object_owner, p.object_owner) AS asset_owner, case\n      when coalesce(j.is_deleted,c.is_deleted, p.is_deleted, w.is_deleted) = 1\n      then 'deleted' WHEN coalesce(j.is_deleted,c.is_deleted, p.is_deleted, w.is_deleted) = 0\n      then 'active'\n      else 'unknown'\n    end AS is_deleted, coalesce(tk.asset_name, j.object_name,c.object_name, p.object_name, w.object_name, usage_metadata.endpoint_name, usage_metadata.notebook_path, 'unknown') AS clean_asset_name, -----==== Route to the object itself ====----- case\n      when billing_origin_product = 'ALL_PURPOSE'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/compute/clusters/', usage_metadata.cluster_id) -- AP clusters WHEN billing_origin_product = 'INTERACTIVE'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/editor/notebooks/', usage_metadata.notebook_id) -- Serverless All purpose usage WHEN billing_origin_product = 'JOBS'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/jobs/', usage_metadata.job_id) -- works for regular and serverless WHEN billing_origin_product = 'SQL'\n      then case\n      when usage_metadata.warehouse_id IS NOT NULL\n      then CONCAT(COALESCE(workspace_url, ''),\n '/sql/warehouses/', usage_metadata.warehouse_id, '?o=', tk.workspace_id)\n      else CONCAT(COALESCE(workspace_url, ''),\n '/pipelines/', usage_metadata.dlt_pipeline_id, '?o=', tk.workspace_id)\n    end -- Can be SQL Warehouse or DLT Serverless\nfrom\n    ST/MVs WHEN billing_origin_product = 'DLT'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/pipelines/', usage_metadata.dlt_pipeline_id) WHEN billing_origin_product = 'ONLINE_TABLES'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/pipelines/', usage_metadata.dlt_pipeline_id) WHEN billing_origin_product = 'APPS'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/apps/', usage_metadata.app_name) WHEN billing_origin_product = 'NOTEBOOKS'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/editor/notebooks/', usage_metadata.notebook_id) -- There is a separate SKU for notebooks for some reason WHEN billing_origin_product = 'PREDICTIVE_OPTIMIZATION'\n      then NULL -- background service WHEN billing_origin_product = 'CLEAN_ROOM'\n      then case\n      when asset_name IS NULL\n      then NULL\n      else CONCAT(COALESCE(workspace_url, ''),\n '/explore/cleanrooms/', COALESCE(asset_name, usage_metadata.central_clean_room_id),\n '?o=', COALESCE(tk.workspace_id, ''))\n    end WHEN billing_origin_product = 'LAKEFLOW_CONNECT'\n      then CONCAT('/pipelines/', usage_metadata.dlt_pipeline_id) WHEN billing_origin_product = 'AI_RUNTIME'\n      then NULL -- NOT SUPPORTED WHEN billing_origin_product = 'MODEL_SERVING'\n      then (case\n      when usage_metadata.endpoint_name IS NOT NULL -- Model Serving control panel is by name\n      then CONCAT(COALESCE(workspace_url, ''),\n '/ml/endpoints/', usage_metadata.endpoint_name) WHEN usage_metadata.endpoint_id IS NOT NULL\n      then NULL --  TO DO - find way to link with id WHEN custom_tags.EndpointId IS NOT NULL\n      then NULL --  TO DO - find way to link with id WHEN usage_metadata.cluster_id IS NOT NULL\n      then NULL --  TO DO - find way to link with id END) WHEN billing_origin_product = 'VECTOR_SEARCH'\n      then CONCAT(COALESCE(workspace_url, ''),\n CONCAT('/compute/vector-search/', usage_metadata.endpoint_name),\n '?o=', COALESCE(tk.workspace_id, '')) WHEN billing_origin_product = 'DATABASE'\n      then NULL -- TBD -- WHEN billing_origin_product = 'LAKEHOUSE_MONITORING'\n      then custom_tags.LakehouseMonitoringTableId -- TO DO - Needs better link identifier and more than just table Id to link to monitor\n    end AS asset_url_router, -----==== Asset Identifier (id or name if no id) ====----- case\n      when billing_origin_product = 'ALL_PURPOSE'\n      then usage_metadata.cluster_id -- AP clusters WHEN billing_origin_product = 'INTERACTIVE'\n      then case\n      when usage_metadata.notebook_id IS NOT NULL\n      then usage_metadata.notebook_id WHEN product_features.is_serverless = True\n      then asset_owner\n    end -- Serverless All purpose usage WHEN billing_origin_product = 'NETWORKING'\n      then CONCAT(usage_metadata.source_region, ' -> ',usage_metadata.destination_region) WHEN billing_origin_product = 'FINE_GRAINED_ACCESS_CONTROL'\n      then case\n      when product_features.is_serverless = True\n      then asset_owner\n    end WHEN billing_origin_product = 'AGENT_EVALUATION'\n      then asset_owner -- user doing agent eval WHEN billing_origin_product = 'JOBS'\n      then usage_metadata.job_id -- works for regular and serverless WHEN billing_origin_product = 'SQL'\n      then case\n      when usage_metadata.warehouse_id IS NOT NULL\n      then usage_metadata.warehouse_id\n      else usage_metadata.dlt_pipeline_id\n    end -- Can be SQL Warehouse or DLT Serverless\nfrom\n    ST/MVs WHEN billing_origin_product = 'DLT'\n      then case\n      when usage_metadata.dlt_pipeline_id IS NOT NULL\n      then usage_metadata.dlt_pipeline_id WHEN usage_metadata.cluster_id IS NOT NULL\n      then usage_metadata.cluster_id\n    end -- Can be pipeline id or cluster id for classic DLT WHEN billing_origin_product = 'ONLINE_TABLES'\n      then usage_metadata.dlt_pipeline_id WHEN billing_origin_product = 'APPS'\n      then usage_metadata.app_name WHEN billing_origin_product = 'CLEAN_ROOM'\n      then usage_metadata.central_clean_room_id WHEN billing_origin_product = 'NOTEBOOKS'\n      then usage_metadata.notebook_id -- There is a separate SKU for notebooks for some reason WHEN billing_origin_product = 'PREDICTIVE_OPTIMIZATION'\n      then 'Background Service' -- background service WHEN billing_origin_product = 'LAKEFLOW_CONNECT'\n      then usage_metadata.dlt_pipeline_id WHEN billing_origin_product = 'AI_RUNTIME'\n      then usage_metadata.ai_runtime_pool_id WHEN billing_origin_product = 'MODEL_SERVING'\n      then (case\n      when usage_metadata.endpoint_name IS NOT NULL -- Model Serving control panel is by name\n      then usage_metadata.endpoint_name WHEN usage_metadata.endpoint_id IS NOT NULL\n      then usage_metadata.endpoint_id WHEN custom_tags.EndpointId IS NOT NULL\n      then custom_tags.EndpointId WHEN usage_metadata.cluster_id IS NOT NULL\n      then usage_metadata.cluster_id END) WHEN billing_origin_product = 'VECTOR_SEARCH'\n      then COALESCE(usage_metadata.endpoint_name, usage_metadata.dlt_pipeline_id) WHEN billing_origin_product = 'FOUNDATION_MODEL_TRAINING'\n      then usage_metadata.run_name -- TO DO - Needs better link identifier and experiemnt Id and user id WHEN billing_origin_product = 'LAKEHOUSE_MONITORING'\n      then custom_tags.LakehouseMonitoringTableId -- TO DO - Needs better link identifier and more than just table Id to link to monitor WHEN billing_origin_product = 'DATABASE'\n      then usage_metadata.database_instance_id -- TBD\n    end AS asset_id, -----==== Type of Asset (id/name description) ====----- case\n      when billing_origin_product = 'ALL_PURPOSE'\n      then 'All Purpose Cluster Id' -- AP clusters WHEN billing_origin_product = 'INTERACTIVE'\n      then case\n      when usage_metadata.notebook_id IS NOT NULL\n      then 'Serverless Notebook Id' WHEN product_features.is_serverless = True\n      then 'Serverless Interactive Usage'\n    end WHEN billing_origin_product = 'NETWORKING'\n      then 'Network Route' WHEN billing_origin_product = 'FINE_GRAINED_ACCESS_CONTROL'\n      then case\n      when product_features.is_serverless = True\n      then 'Fine Grained Access Filtering'\n    end WHEN billing_origin_product = 'AGENT_EVALUATION'\n      then 'User Agent Evaluation' -- user doing agent eval WHEN billing_origin_product = 'JOBS'\n      then 'Workflow - Job Id' -- works for regular and serverless WHEN billing_origin_product = 'SQL'\n      then case\n      when usage_metadata.warehouse_id IS NOT NULL\n      then 'SQL Warehouse'\n      else 'SQL - DLT ST/MVs'\n    end -- Can be SQL Warehouse or DLT Serverless\nfrom\n    ST/MVs WHEN billing_origin_product = 'DLT'\n      then case\n      when usage_metadata.dlt_pipeline_id IS NOT NULL\n      then 'DLT Pipeline Id' WHEN usage_metadata.cluster_id IS NOT NULL\n      then 'DLT Cluster Id'\n    end -- Can be pipeline id or cluster id for classic DLT WHEN billing_origin_product = 'ONLINE_TABLES'\n      then 'Online Table DLT Pipeline Id' -- 'Not yet recorded' WHEN billing_origin_product = 'APPS'\n      then 'Lakehouse App Name' WHEN billing_origin_product = 'CLEAN_ROOM'\n      then 'Cleanroom Id / Name' WHEN billing_origin_product = 'LAKEFLOW_CONNECT'\n      then 'Lakeflow Pipeline Id' WHEN billing_origin_product = 'AI_RUNTIME'\n      then 'AI Runtime Pool Id' WHEN billing_origin_product = 'NOTEBOOKS'\n      then 'Serverless Notebook Id'-- There is a separate SKU for notebooks for some reason WHEN billing_origin_product = 'PREDICTIVE_OPTIMIZATION'\n      then 'Predictive Optimization Usage' -- background service WHEN billing_origin_product = 'MODEL_SERVING'\n      then (case\n      when usage_metadata.endpoint_name IS NOT NULL -- Model Serving control panel is by name\n      then 'Model Serving Endpoint Name' WHEN usage_metadata.endpoint_id IS NOT NULL\n      then 'Model Serving Endpoint Id' WHEN custom_tags.EndpointId IS NOT NULL\n      then 'Model Serving Endpoint Id' WHEN usage_metadata.cluster_id IS NOT NULL\n      then 'Model Serving Cluster Id' END) WHEN billing_origin_product = 'VECTOR_SEARCH'\n      then 'Vector Search Endpoint Name' -- TO DO - Needs better link identifier and owner info - Need Vector search name WHEN billing_origin_product = 'FOUNDATION_MODEL_TRAINING'\n      then 'Training Experiment Run'-- TO DO - Needs better link identifier and experiemnt Id and user id WHEN billing_origin_product = 'LAKEHOUSE_MONITORING'\n      then 'Table Id Monitor' -- TO DO - Needs better link identifier and more than just table Id to link to monitor WHEN billing_origin_product = 'DATABASE'\n      then 'Database Instance Id' -- TO DO - Needs better link identifier via database name\n    end AS asset_type, case\n      when asset_id IS NOT NULL\n      then 'Identified'\n      else 'Unknown Asset Id'\n    end AS IsClassifiedIntoAsset, case\n      when :param_time_key = 'Day'\n      then :time_range.max when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max)\n    end as current_period, case\n      when :param_time_key = 'Day'\n      then :time_range.max - interval 1 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max - interval 7 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max - interval 1 month)\n    end as last_period, tk.*\nfrom\n    (select\n    *\nfrom\n    list_priced_usd_with_matching_tag_kvp\nwhere\n    (case\n      when :param_show_tag_mismatch = 'All Usage'\n      then True WHEN :param_show_tag_mismatch = 'Not Matched Only'\n      then IsMatched IN ('<NO TAG MATCH>', '<NOT TAGGED>') WHEN :param_show_tag_mismatch = 'Matched Only'\n      then IsMatched NOT IN ('<NO TAG MATCH>', '<NOT TAGGED>') END)) AS tk\n  LEFT join\n    jobs j\n    on j.job_id = tk.job_id\n  LEFT join\n    clusters c\n    on c.cluster_id = tk.cluster_id\n  LEFT join\n    pipelines p\n    on p.pipeline_id = tk.dlt_pipeline_id\n  LEFT join\n    warehouses w\n    on w.warehouse_id = tk.warehouse_id ),\n agg_final AS ( -- Aggregate select\n    workspace AS workspace_id, billing_origin_product, asset_type, asset_id, case\n      when :enable_links_toggle = 'Enabled'\n      then asset_url_router\n      else NULL\n    end AS asset_url_router, IsClassifiedIntoAsset, IsServerless, usage_type, COALESCE(MAX(is_deleted),\n 'unknown') AS is_object_deleted, FIRST(current_period) AS current_period, FIRST(last_period) AS last_period, SUM(   -- Make dynamic case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd\n    end ) FILTER(WHERE usage_date >= current_period) as current_period_usage_usd, SUM(case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd\n    end ) FILTER(WHERE usage_date BETWEEN last_period AND current_period) as last_period_usage_usd, MAX_BY(COALESCE(asset_owner),\n usage_end_time) AS usage_owner, -- Most recent asset name (they can change) MAX_BY(clean_asset_name, usage_end_time) AS MostRecentAssetName, -- Most recent is matched MAX_BY(IsMatched, usage_end_time) AS MostRecentIsMatched, -- Most recent tag pairs MAX_BY(custom_tag_key_value_pairs, usage_end_time) AS MostRecentTagKeyValuePairs, -- Most recent usage date MAX_BY(usage_date, usage_end_time) AS MostRecentUsageDate, -- Days since most recent usage date_diff(current_date()::date, MostRecentUsageDate) AS DaysSinceMostRecentUsage, -- First Usage Date In Window MIN_BY(usage_date, usage_end_time) AS EarliestUsageDate, -- Total Usage SUM(case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd\n    end ) AS TotalDollarsUsage, SUM(usage_quantity) AS TotalDBUUsageQuantity, -- Most recent custom_tags value MAX_BY(custom_tags, usage_end_time) AS MostRecentTagsOnAsset, -- Most recent usage metadata MAX_BY(usage_metadata, usage_end_time) AS MostRecentUsageMetadata, MAX_BY(identity_metadata, usage_end_time) AS MostRecentIdentityMetadata, MAX_BY(product_features, usage_end_time) AS MostRecentProductFeatures\nfrom\n    pre_results GROUP BY workspace, billing_origin_product, asset_type, asset_id, case\n      when :enable_links_toggle = 'Enabled'\n      then asset_url_router\n      else NULL END, IsClassifiedIntoAsset, IsServerless, usage_type ),\n asset_ranks AS ( select\n    CONCAT( '<span style=\"color:', case\n      when MostRecentIsMatched = '<NOT TAGGED>'\n      then '#919191' WHEN MostRecentIsMatched = '<NO TAG MATCH>'\n      then '#AB4057' WHEN MostRecentIsMatched = '<TAG MATCH>'\n      then '#00A972'\n      else 'inherit' END, '; font-weight: bold', ';\">', REPLACE(REPLACE(MostRecentIsMatched, '<', '&lt;'),\n '>', '&gt;'),\n '</span>' ) AS MatchedKey_html, case\n      when MostRecentIsMatched = '<NOT TAGGED>'\n      then 'NOT TAGGED' WHEN MostRecentIsMatched = '<NO TAG MATCH>'\n      then 'NO TAG MATCH' WHEN MostRecentIsMatched = '<TAG MATCH>'\n      then 'MATCHED'\n    end AS clean_ui_is_matched, af.*, -- PoP usage change case\n      when last_period_usage_usd IS NULL\n      then 0\n      else ROUND((try_divide((current_period_usage_usd - last_period_usage_usd),\n last_period_usage_usd))*100, 2)\n    end AS percent_pop_change, -- add data bars\n    on USAGE MAX(TotalDollarsUsage) OVER() AS max_usage_dollars, MIN(TotalDollarsUsage) OVER() AS min_usage_dollars, COALESCE(CONCAT( '<div style=\"position: relative; height: 20px; border-radius: 4px; overflow: hidden;\">', '<div style=\"position: absolute; width: ', ROUND(try_divide((TotalDollarsUsage - min_usage_dollars),\n NULLIF(max_usage_dollars - min_usage_dollars, 0)) * 100, 2),\n '%; height: 100%; background: #077A9D; border-radius: 4px;\"></div>', '<span style=\"position: absolute; width: 100%; text-align: center; line-height: 20px; font-weight: bold; color: #00A972;\">', case\n      when :usage_toggle = 'Dollars'\n      then '$'\n      else '' END, FORMAT_NUMBER(TotalDollarsUsage, 0),\n '</span></div>' ),\n CAST(TotalDollarsUsage AS STRING)) AS usage_dollars_html, MAX(DaysSinceMostRecentUsage) OVER() AS max_usage_days, MIN(DaysSinceMostRecentUsage) OVER() AS min_usage_days, CONCAT( '<span style=\"display: block; width: 100%; padding: 5px; color: white; background-color: rgba(', -- Interpolate RGB values for the gradient\nfrom\n    green to red ROUND( 171 * ((DaysSinceMostRecentUsage - min_usage_days) / NULLIF(max_usage_days - min_usage_days, 0)) + 0 * (1 - ((DaysSinceMostRecentUsage - min_usage_days) / NULLIF(max_usage_days - min_usage_days, 0))) ),\n ',', -- Red channel ROUND( 64 * ((DaysSinceMostRecentUsage - min_usage_days) / NULLIF(max_usage_days - min_usage_days, 0)) + 169 * (1 - ((DaysSinceMostRecentUsage - min_usage_days) / NULLIF(max_usage_days - min_usage_days, 0))) ),\n ',', -- Green channel ROUND( 87 * ((DaysSinceMostRecentUsage - min_usage_days) / NULLIF(max_usage_days - min_usage_days, 0)) + 114 * (1 - ((DaysSinceMostRecentUsage - min_usage_days) / NULLIF(max_usage_days - min_usage_days, 0))) ),\n ',', -- Blue channel '0.8); border-radius: 4px;\">', ROUND(DaysSinceMostRecentUsage, 1),\n ' days</span>' ) AS heat_color_html, ROW_NUMBER() OVER(ORDER BY TotalDollarsUsage DESC) AS top_n_asset\nfrom\n    agg_final af ) select\n    *\nfrom\n    asset_ranks\nwhere\n    top_n_asset <= :top_n_asset ORDER BY TotalDollarsUsage DESC",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.list_prices"
      },
      {
        "displayName": "param_tag_entries",
        "keyword": "param_tag_entries",
        "dataType": "STRING",
        "defaultValue": "Budget;Env"
      },
      {
        "displayName": "group_agg_mode",
        "keyword": "group_agg_mode",
        "dataType": "STRING",
        "defaultValue": "Key-Value Pairs"
      },
      {
        "displayName": "normalize_case",
        "keyword": "normalize_case",
        "dataType": "STRING",
        "defaultValue": "Yes"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Month"
      },
      {
        "displayName": "param_show_tag_mismatch",
        "keyword": "param_show_tag_mismatch",
        "dataType": "STRING",
        "defaultValue": "All Usage"
      },
      {
        "displayName": "enable_links_toggle",
        "keyword": "enable_links_toggle",
        "dataType": "STRING",
        "defaultValue": "Enabled"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      },
      {
        "displayName": "top_n_asset",
        "keyword": "top_n_asset",
        "dataType": "DECIMAL",
        "defaultValue": "50"
      },
      {
        "displayName": "tag_search_mode",
        "keyword": "tag_search_mode",
        "dataType": "STRING",
        "defaultValue": "AND"
      }
    ]
  },
  {
    "displayName": "top_spending_assets_summary",
    "sqlQuery": "SET ansi_mode = True; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace -- Must assume this works to filter\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    *, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = True\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) -- Serverless AND (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) as usage_year, date_trunc('QUARTER', usage_date) as usage_quarter, date_trunc('MONTH', usage_date) as usage_month, date_trunc('WEEK', usage_date) as usage_week, MIN(usage_date) OVER () AS start_time, MAX(usage_date) OVER () AS end_time, u.*\nfrom\n    usage_filtered as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n -- eval time_key param list_priced_usd_with_time_key as ( select\n    identifier ( case\n      when :param_time_key = 'Year'\n      then 'usage_year' when :param_time_key = 'Quarter'\n      then 'usage_quarter' when :param_time_key = 'Month'\n      then 'usage_month' when :param_time_key = 'Week'\n      then 'usage_week' when :param_time_key = 'Day'\n      then 'usage_date'\n      else 'usage_date'\n    end )::date as time_key, *\nfrom\n    list_priced_usd ),\n -- eval rank_key param list_priced_usd_with_rank_key as ( select\n    struct(workspace) as rank_metadata, identifier ( case\n      when :param_rank_key = 'workspace'\n      then 'rank_metadata' when :param_rank_key = 'run_as'\n      then 'identity_metadata'\n      else 'usage_metadata'\n    end )[:param_rank_key] as rank_key, *\nfrom\n    list_priced_usd_with_time_key ),\n -- calc top ranked usage top_ranked_usage as ( select\n    rank_key, true as is_top_ranked, sum( case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd\n    end ) as usage_usd\nfrom\n    list_priced_usd_with_rank_key\nwhere\n    rank_key is not null group by rank_key order by usage_usd desc limit :param_top_n ),\n list_priced_usd_with_rank_key_normalized as ( select\n    if(is_top_ranked or u.rank_key is null, u.rank_key, '<REMAINING OBJECTS>') as rank_key, u.time_key, u.workspace, case\n      when :usage_toggle = 'Dollars'\n      then u.usage_usd WHEN :usage_toggle = 'DBUs'\n      then u.usage_dbus\n      else u.usage_usd\n    end AS usage_usd\nfrom\n    list_priced_usd_with_rank_key as u\n  left join\n    top_ranked_usage\n    on u.rank_key = top_ranked_usage.rank_key\nwhere\n    case\n      when :include_remaining_assets = 'Yes'\n      then u.rank_key is not null\n      else top_ranked_usage.rank_key IS NOT NULL\n    end ) -- query select\n    COALESCE(rank_key, '<OTHER OBJECT TYPES>') AS rank_key, time_key, workspace, sum(usage_usd) as usage_usd\nfrom\n    list_priced_usd_with_rank_key_normalized group by all",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Month"
      },
      {
        "displayName": "param_rank_key",
        "keyword": "param_rank_key",
        "dataType": "STRING",
        "defaultValue": "job_id"
      },
      {
        "displayName": "param_top_n",
        "keyword": "param_top_n",
        "dataType": "INTEGER",
        "defaultValue": "10"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "include_remaining_assets",
        "keyword": "include_remaining_assets",
        "dataType": "STRING",
        "defaultValue": "Yes"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.list_prices"
      }
    ]
  },
  {
    "displayName": "top_spending_assets_pop_matrix",
    "sqlQuery": "SET ansi_mode = True; with\n  workspace as (\n     select\n    account_id, workspace_id, workspace_name, workspace_url, status, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')') AS workspace_full_name\nfrom\n    system.access.workspaces_latest\nwhere\n    (array_contains(:param_workspace, concat(COALESCE(workspace_name, ''),\n ' (id: ', workspace_id, ')')) OR array_contains(:param_workspace,'all')) ),\n -- apply date filter usage_with_ws_filtered_by_date as ( select\n    case\n      when workspace_name is null\n      then concat('id: ', u.workspace_id)\n      else workspace_full_name\n    end as workspace, workspace_url, u.*\nfrom\n    system.billing.usage as u\n  inner join\n    workspace -- Must assume this works to filter\n    on u.workspace_id = workspace.workspace_id\nwhere\n    u.usage_date between :time_range.min and :time_range.max ),\n -- apply workspace filter usage_filtered as ( select\n    *, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic'\n    end AS IsServerless, case\n      when product_features.is_photon = True\n      then 'Photon'\n      else 'Spark'\n    end AS IsPhoton\nfrom\n    usage_with_ws_filtered_by_date\nwhere\n    -- Product SKU filter (array_contains(:product_category, billing_origin_product) OR array_contains(:product_category,'all')) -- Serverless AND (array_contains(:is_serverless, case\n      when product_features.is_serverless = True\n      then 'Serverless'\n      else 'Classic' END) OR array_contains(:is_serverless,'all')) ),\n parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, sku_name, usage_unit, price_start_time, case\n      when :price_table = 'system.billing.list_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.effective_list.default', 'decimal(38,18)') WHEN :price_table = 'system.billing.account_prices'\n      then try_variant_get(to_variant_object(pricing),\n '$.default', 'decimal(38,18)')\n    end AS unit_px\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n list_priced_usd as ( select\n    /*+ BROADCAST(p) */ -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.unit_px * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.unit_px * u.usage_quantity, -- When all\n      else fails, use default p.unit_px * u.usage_quantity) as usage_usd, usage_quantity AS usage_dbus, date_trunc('YEAR', usage_date) as usage_year, date_trunc('QUARTER', usage_date) as usage_quarter, date_trunc('MONTH', usage_date) as usage_month, date_trunc('WEEK', usage_date) as usage_week, MIN(usage_date) OVER () AS start_time, MAX(usage_date) OVER () AS end_time, u.*\nfrom\n    usage_filtered as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on (discounts.product = u.sku_name OR discounts.product = u.billing_origin_product)\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n -- Some links require the name, this is expensive so use sparingly asset_names AS ( select\n    usage_metadata.central_clean_room_id AS asset_id, MAX_BY(clean_room_name, ce.event_time) AS asset_name\nfrom\n    list_priced_usd s\n  LEFT join\n    system.access.clean_room_events ce\n    on ce.central_clean_room_id = s.usage_metadata.central_clean_room_id\nwhere\n    billing_origin_product = 'CLEAN_ROOM' GROUP BY usage_metadata.central_clean_room_id ),\n -- eval time_key param list_priced_usd_with_time_key as ( select\n    (case\n      when :param_time_key = 'Year'\n      then usage_year when :param_time_key = 'Quarter'\n      then usage_quarter when :param_time_key = 'Month'\n      then usage_month when :param_time_key = 'Week'\n      then usage_week when :param_time_key = 'Day'\n      then usage_date\n      else usage_date\n    end )::date as time_key, *\nfrom\n    list_priced_usd ),\n -- eval rank_key param list_priced_usd_with_rank_key as ( select\n    struct(workspace) as rank_metadata, identifier ( case\n      when :param_rank_key = 'workspace'\n      then 'rank_metadata' when :param_rank_key = 'run_as'\n      then 'identity_metadata'\n      else 'usage_metadata'\n    end )[:param_rank_key] as rank_key, *\nfrom\n    list_priced_usd_with_time_key ),\n -- calc top ranked usage top_ranked_usage as ( select\n    rank_key, true as is_top_ranked, sum( case\n      when :usage_toggle = 'Dollars'\n      then usage_usd WHEN :usage_toggle = 'DBUs'\n      then usage_dbus\n      else usage_usd\n    end ) as usage_usd\nfrom\n    list_priced_usd_with_rank_key\nwhere\n    rank_key is not null group by rank_key order by usage_usd desc limit :param_top_n ),\n list_priced_usd_with_rank_key_normalized as ( select\n    /*+ BROADCAST(aa),\n BROADCAST(top_ranked_usage) */ if(is_top_ranked or u.rank_key is null, u.rank_key, 'REMAINING OBJECTS') as rank_key, u.time_key, case\n      when :usage_toggle = 'Dollars'\n      then u.usage_usd WHEN :usage_toggle = 'DBUs'\n      then u.usage_dbus\n      else u.usage_usd\n    end AS usage_usd, case\n      when u.rank_key != 'REMAINING OBJECTS'\n      then coalesce(identity_metadata.run_as, identity_metadata.owned_by, identity_metadata.created_by)\n    end AS usage_owner, -----==== Route to the asset itself ====----- case\n      when u.rank_key != 'REMAINING OBJECTS'\n      then case\n      when :param_rank_key = 'workspace'\n      then workspace_url WHEN :param_rank_key = 'run_as'\n      then NULL WHEN billing_origin_product = 'ALL_PURPOSE'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/compute/clusters/', usage_metadata.cluster_id) -- AP clusters WHEN billing_origin_product = 'INTERACTIVE'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/editor/notebooks/', usage_metadata.notebook_id) -- Serverless All purpose usage WHEN billing_origin_product = 'JOBS'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/jobs/', usage_metadata.job_id) -- works for regular and serverless WHEN billing_origin_product = 'SQL'\n      then case\n      when usage_metadata.warehouse_id IS NOT NULL\n      then CONCAT(COALESCE(workspace_url, ''),\n '/sql/warehouses/', usage_metadata.warehouse_id, '?o=', workspace_id)\n      else CONCAT(COALESCE(workspace_url, ''),\n '/pipelines/', usage_metadata.dlt_pipeline_id, '?o=', workspace_id)\n    end -- Can be SQL Warehouse or DLT Serverless\nfrom\n    ST/MVs WHEN billing_origin_product = 'DLT'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/pipelines/', usage_metadata.dlt_pipeline_id) WHEN billing_origin_product = 'ONLINE_TABLES'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/pipelines/', usage_metadata.dlt_pipeline_id) WHEN billing_origin_product = 'APPS'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/apps/', usage_metadata.app_name) WHEN billing_origin_product = 'NOTEBOOKS'\n      then CONCAT(COALESCE(workspace_url, ''),\n '/editor/notebooks/', usage_metadata.notebook_id) -- There is a separate SKU for notebooks for some reason WHEN billing_origin_product = 'PREDICTIVE_OPTIMIZATION'\n      then NULL -- background service WHEN billing_origin_product = 'CLEAN_ROOM'\n      then case\n      when aa.asset_name IS NULL\n      then NULL\n      else CONCAT(COALESCE(workspace_url, ''),\n '/explore/cleanrooms/', COALESCE(aa.asset_name, usage_metadata.central_clean_room_id),\n '?o=', COALESCE(workspace_id, ''))\n    end WHEN billing_origin_product = 'LAKEFLOW_CONNECT'\n      then CONCAT('/pipelines/', usage_metadata.dlt_pipeline_id) WHEN billing_origin_product = 'AI_RUNTIME'\n      then NULL -- NOT SUPPORTED WHEN billing_origin_product = 'MODEL_SERVING'\n      then (case\n      when usage_metadata.endpoint_name IS NOT NULL -- Model Serving control panel is by name\n      then CONCAT(COALESCE(workspace_url, ''),\n '/ml/endpoints/', usage_metadata.endpoint_name) WHEN usage_metadata.endpoint_id IS NOT NULL\n      then NULL --  TO DO - find way to link with id WHEN custom_tags.EndpointId IS NOT NULL\n      then NULL --  TO DO - find way to link with id WHEN usage_metadata.cluster_id IS NOT NULL\n      then NULL --  TO DO - find way to link with id END) WHEN billing_origin_product = 'VECTOR_SEARCH'\n      then CONCAT(COALESCE(workspace_url, ''),\n CONCAT('/compute/vector-search/', usage_metadata.endpoint_name),\n '?o=', COALESCE(workspace_id, '')) -- WHEN billing_origin_product = 'LAKEHOUSE_MONITORING'\n      then custom_tags.LakehouseMonitoringTableId -- TO DO - Needs better link identifier and more than just table Id to link to monitor WHEN billing_origin_product = 'DATABASE'\n      then NULL -- TO DO\n    end END AS asset_url_router\nfrom\n    list_priced_usd_with_rank_key as u\n  left join\n    top_ranked_usage\n    on u.rank_key = top_ranked_usage.rank_key\n  left join\n    asset_names aa\n    on u.usage_metadata.central_clean_room_id = aa.asset_id\nwhere\n    case\n      when :include_remaining_assets = 'Yes'\n      then u.rank_key is not null\n      else top_ranked_usage.rank_key IS NOT NULL\n    end ),\n group_key_routes AS ( select\n    rank_key, MAX_BY(asset_url_router, time_key) AS latest_asset_route, MAX_BY(usage_owner, time_key) AS latest_asset_owner\nfrom\n    list_priced_usd_with_rank_key_normalized\nwhere\n    rank_key != 'REMAINING OBJECTS' GROUP BY rank_key ),\n -- calc usage by period grouped_usage_by_period as ( select\n    time_key as period_key, rank_key as group_key, sum(usage_usd) as usage_usd\nfrom\n    list_priced_usd_with_rank_key_normalized group by time_key, rank_key ),\n -- calc periodic change grouped_usage_change as ( select\n    period_key, group_key, usage_usd, lag(usage_usd, 1) over (partition by group_key order by period_key) as prev_usage_usd, round(try_divide((usage_usd - prev_usage_usd),\n prev_usage_usd) * 100, 2) as usage_change_percentage\nfrom\n    grouped_usage_by_period ),\n total_usage_change as ( select\n    period_key, 'TOTAL' as group_key, sum(usage_usd) as usage_usd, lag(sum(usage_usd),\n 1) over (order by period_key) as prev_usage_usd, round(try_divide((sum(usage_usd) - prev_usage_usd),\n prev_usage_usd) * 100, 2) as usage_change_percentage\nfrom\n    grouped_usage_by_period group by period_key ),\n -- periods period_info as ( select\n    case\n      when :param_time_key = 'Day'\n      then :time_range.max::date when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date)\n    end as current_period, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date- interval 1 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 7 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 1 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 3 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 1 year)\n    end as last_period, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 2 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 14 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 2 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 6 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 2 year)\n    end as 2_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 3 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 21 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 3 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 9 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 3 year)\n    end as 3_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 4 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 28 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 4 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 12 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 4 year)\n    end as 4_periods_ago, case\n      when :param_time_key = 'Day'\n      then :time_range.max::date - interval 5 day when :param_time_key = 'Week'\n      then date_trunc('WEEK', :time_range.max::date - interval 35 day) when :param_time_key = 'Month'\n      then date_trunc('MONTH', :time_range.max::date - interval 5 month) when :param_time_key = 'Quarter'\n      then date_trunc('QUARTER', :time_range.max::date - interval 15 month) when :param_time_key = 'Year'\n      then date_trunc('YEAR', :time_range.max::date - interval 5 year)\n    end as 5_periods_ago ),\n -- pivot change usage_change_pivot as ( select\n    case\n      when period_key = current_period\n      then 'Current period' when period_key = last_period\n      then 'Last period' when period_key = 2_periods_ago\n      then '2 periods ago' when period_key = 3_periods_ago\n      then '3 periods ago' when period_key = 4_periods_ago\n      then '4 periods ago' when period_key = 5_periods_ago\n      then '5 periods ago'\n    end as x_period_back, group_key, usage_usd, usage_change_percentage\nfrom\n    ( select\n    *\nfrom\n    grouped_usage_change, period_info union all select\n    *\nfrom\n    total_usage_change, period_info ) ),\n -- pivot all time all_time_usage_pivot as ( select\n    'Start to\n    end date' as x_period_back, group_key, sum(usage_usd) as usage_usd, null as usage_change_percentage\nfrom\n    grouped_usage_by_period group by group_key ),\n -- pivot total all time all_time_total_usage_pivot as ( select\n    'Start to\n    end date' as x_period_back, 'TOTAL' as group_key, sum(usage_usd) as usage_usd, null as usage_change_percentage\nfrom\n    grouped_usage_by_period ),\n union_usage_pivot as ( select\n    x_period_back, group_key, case\n      when x_period_back = 'Start to\n    end date'\n      then string(usage_usd)\n      else concat('<span style=\"zoom:1\">', usage_usd_str, '</span><span style=\"zoom:1;color:', change_color, '\">&nbsp;', usage_change_str, '</span>')\n    end as usage_info\nfrom\n    ( select\n    case\n      when usage_usd >= 1e9\n      then concat(format_number(usage_usd / 1e9, 0),\n 'B') when usage_usd >= 1e6\n      then concat(format_number(usage_usd / 1e6, 0),\n 'M') when usage_usd >= 1e3\n      then concat(format_number(usage_usd / 1e3, 0),\n 'K')\n      else format_number(usage_usd, 0)\n    end as usage_usd_str, case\n      when usage_change_percentage > 10\n      then '#00A972' when usage_change_percentage < -10\n      then '#FF3621'\n      else '#919191'\n    end as _change_color, concat('(', if(usage_change_percentage > 0, '+', ''),\n format_number(usage_change_percentage, 0),\n '%)') as _usage_change_str, coalesce(_change_color, '#919191') as change_color, coalesce(_usage_change_str, '') as usage_change_str, *\nfrom\n    ( select\n    x_period_back, group_key, usage_usd, usage_change_percentage\nfrom\n    usage_change_pivot union all select\n    *\nfrom\n    all_time_usage_pivot union all select\n    *\nfrom\n    all_time_total_usage_pivot ) ) ),\n pre_format_results AS ( -- query select\n    group_key, case\n      when :usage_toggle = 'Dollars'\n      then concat('$', format_number(float(`Start to\n    end date`),\n 0)) WHEN :usage_toggle = 'DBUs'\n      then concat('', format_number(float(`Start to\n    end date`),\n 0))\n      else concat('$', format_number(float(`Start to\n    end date`),\n 0))\n    end as `Start to\n    end date`, float(`Start to\n    end date`) as _all_time_usage_usd, 2 as _order, coalesce(`5 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `5 periods ago`, coalesce(`4 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `4 periods ago`, coalesce(`3 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `3 periods ago`, coalesce(`2 periods ago`, '<span style=\"zoom:1;color:#919191\">0</span>') as `2 periods ago`, coalesce(`Last period`, '<span style=\"zoom:1;color:#919191\">0</span>') as `Last period`, coalesce(`Current period`, '<span style=\"zoom:1;color:#919191\">0</span>') as `Current period`\nfrom\n    union_usage_pivot pivot ( first(usage_info) for x_period_back in ( 'Start to\n    end date', '5 periods ago', '4 periods ago', '3 periods ago', '2 periods ago', 'Last period', 'Current period' ) ) union all ( select\n    '' as group_key, concat('<b><i>', date_format(:time_range.min, 'MMM dd yyyy'),\n ' - ', date_format(:time_range.max, 'MMM dd yyyy'),\n '</i></b>') as `Start to\n    end date`, null as _all_time_usage_usd, 1 as _order, concat('<b><i>', date_format(5_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(4_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `5 periods ago`, concat('<b><i>', date_format(4_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(3_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `4 periods ago`, concat('<b><i>', date_format(3_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(2_periods_ago, -1),\n 'MMM dd'),\n '</i></b>') as `3 periods ago`, concat('<b><i>', date_format(2_periods_ago, 'MMM dd'),\n ' - ', date_format(date_add(last_period, -1),\n 'MMM dd'),\n '</i></b>') as `2 periods ago`, concat('<b><i>', date_format(last_period, 'MMM dd'),\n ' - ', date_format(date_add(current_period, -1),\n 'MMM dd'),\n '</i></b>') as `Last period`, concat('<b><i>', date_format(current_period, 'MMM dd'),\n ' -\n    end Time', '</i></b>') as `Current period`\nfrom\n    period_info ) ) select\n    /*+ BROADCAST(gkr) */ r.*, case\n      when :enable_links_toggle = 'Enabled'\n      then gkr.latest_asset_route\n      else NULL\n    end AS latest_asset_route, gkr.latest_asset_owner, MAX(_all_time_usage_usd) OVER() AS max_usage, MIN(_all_time_usage_usd) OVER() AS min_usage, -- add data bars COALESCE(CONCAT( '<div style=\"position: relative; height: 20px; border-radius: 4px; overflow: hidden;\">', '<div style=\"position: absolute; width: ', ROUND(try_divide((_all_time_usage_usd - min_usage),\n NULLIF(max_usage - min_usage, 0)) * 100, 2),\n '%; height: 100%; background: #077A9D; border-radius: 4px;\"></div>', '<span style=\"position: absolute; width: 100%; text-align: center; line-height: 20px; font-weight: bold; color: #00A972;\">', case\n      when :usage_toggle = 'Dollars'\n      then '$'\n      else '' END, FORMAT_NUMBER(_all_time_usage_usd, 0),\n '</span></div>' ),\n `Start to\n    end date`) AS usage_bar_html\nfrom\n    pre_format_results AS r\n  LEFT join\n    group_key_routes AS gkr\n    on r.group_key = gkr.rank_key order by _order asc, _all_time_usage_usd desc",
    "parameters": [
      {
        "displayName": "param_workspace",
        "keyword": "param_workspace",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "param_time_key",
        "keyword": "param_time_key",
        "dataType": "STRING",
        "defaultValue": "Month"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "time_range",
        "keyword": "time_range",
        "dataType": "DATE",
        "defaultValue": "now-12M/M to now-1M/M",
        "complexType": "RANGE"
      },
      {
        "displayName": "product_category",
        "keyword": "product_category",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "param_rank_key",
        "keyword": "param_rank_key",
        "dataType": "STRING",
        "defaultValue": "warehouse_id"
      },
      {
        "displayName": "usage_toggle",
        "keyword": "usage_toggle",
        "dataType": "STRING",
        "defaultValue": "Dollars"
      },
      {
        "displayName": "param_top_n",
        "keyword": "param_top_n",
        "dataType": "INTEGER",
        "defaultValue": "10"
      },
      {
        "displayName": "include_remaining_assets",
        "keyword": "include_remaining_assets",
        "dataType": "STRING",
        "defaultValue": "Yes"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.list_prices"
      },
      {
        "displayName": "is_serverless",
        "keyword": "is_serverless",
        "dataType": "STRING",
        "defaultValue": "all",
        "complexType": "MULTI"
      },
      {
        "displayName": "enable_links_toggle",
        "keyword": "enable_links_toggle",
        "dataType": "STRING",
        "defaultValue": "Enabled"
      }
    ]
  },
  {
    "displayName": "contract_burndown",
    "sqlQuery": "/* This section is a sample queries that shows how to build a contract burndown analysis given the following input params: 1. Contract Start Date 2. Contract\n    end Date 3. Total Usage Amount of Contract 4. Total Support / Overhead amount of Contract 5. Discounts by product/sku list separataed by ; */ SET ansi_mode = True; WITH -- calc list priced usage in USD prices as ( select\n    coalesce(price_end_time, date_add(current_date, 1)) as coalesced_price_end_time, * , 'list' AS price_type\nfrom\n    IDENTIFIER(:price_table)\nwhere\n    currency_code = 'USD' ),\n contract_dates AS ( select\n    explode(days) AS usage_date\nfrom\n    ( select\n    sequence(:contract_start_date::date, :contract_end_date::date) AS days ) ),\n contract_burndown AS ( select\n    *, SUM(daily_amount) OVER (ORDER BY usage_date) AS cumulative_estimated_contract_usage, try_divide(cumulative_estimated_contract_usage, total_usage_amount) AS estimated_contract_used\nfrom\n    ( select\n    contract_dates.usage_date, :usage_amount::float AS total_usage_amount, :support_amount::float AS total_support_amount, (:usage_amount::float / (select\n    COUNT(0)\nfrom\n    contract_dates)) AS daily_amount\nfrom\n    contract_dates ) ),\n -- Now tag combos can be matched in 2 separate ways: key only, or the key=value pair if optionall provided parsed_discounts_table AS ( with\n  split_data as (\n     select\n    explode(split(regexp_replace(upper(:discounts_by_product),\n '\\\\s+', ''),\n ';')) AS kv_pair\nfrom\n    VALUES(1) AS dummy(x) ),\n clean_keys AS ( select\n    ROW_NUMBER() OVER (ORDER BY kv_pair) AS order_id, split(kv_pair, '=')[0] AS product, try_cast(split(kv_pair, '=')[1] AS decimal(10,3)) AS discount, kv_pair AS combination, case\n      when contains(kv_pair, '=')\n      then 1\n      else 0\n    end AS ContainsValuePair\nfrom\n    split_data ) select\n    *\nfrom\n    clean_keys\nwhere\n    ContainsValuePair = 1 ),\n list_priced_usd as ( select\n    -- Dynamic Prices Logic COALESCE( -- When there is a * global discounts,\n      then use that for all (1-try_cast(regexp_extract(:discounts_by_product, '\\\\s*\\\\*\\\\s*=\\\\s*([0-9]*\\\\.?[0-9]+)', 1) AS decimal(10, 3)))* p.pricing.effective_list.default * u.usage_quantity, -- When no account prices enabled,\n      then use overrides first\n      then default pricing (1-COALESCE(discounts.discount, 0))* p.pricing.effective_list.default * u.usage_quantity, -- When all\n      else fails, use default p.pricing.effective_list.default * u.usage_quantity) as usage_usd, u.*\nfrom\n    system.billing.usage as u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on discounts.product = u.billing_origin_product\n  left join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) ),\n daily_usage AS ( select\n    u.usage_date, SUM(coalesce(((1-COALESCE(discounts.discount, 0))* p.pricing.default)*usage_quantity, u.usage_quantity * p.pricing.default, 0)) AS DollarDBUs, SUM(u.usage_quantity * p.pricing.default) AS ListDollarDBUs, SUM(usage_quantity) AS DBUs\nfrom\n    system.billing.usage AS u\n  LEFT join\n    parsed_discounts_table AS discounts\n    on discounts.product = u.billing_origin_product\n  LEFT join\n    prices as p\n    on u.sku_name=p.sku_name and u.usage_unit=p.usage_unit and (u.usage_end_time between p.price_start_time and p.coalesced_price_end_time) GROUP BY u.usage_date ),\n clean_burn AS ( select\n    c.*, u.usage_date AS u_usage_date, u.DollarDBUs, u.DBUs, (u.DollarDBUs / c.total_usage_amount) * total_support_amount AS SupportDollars, -- Support is burned down in proportion to the usage SUM(DollarDBUs) OVER (ORDER BY c.usage_date) AS cumulative_actual_spend, try_divide(cumulative_actual_spend, total_usage_amount) AS actual_contract_used, -- % completion Flags case\n      when c.usage_date < current_date()\n      then 'Past Usage' WHEN c.usage_date = current_date()\n      then 'Today' WHEN c.usage_date > current_date()\n      then 'Future'\n    end AS TimePeriodFlag\nfrom\n    contract_burndown c\n  LEFT join\n    daily_usage u\n    on c.usage_date = u.usage_date ),\n with_flags AS ( select\n    *, SUM(SupportDollars) OVER (ORDER BY usage_date) AS cumulative_actual_spend_support, case\n      when usage_date >= current_date()\n      then current_date()::date\n      else usage_date::date\n    end AS contract_active_date, case\n      when cumulative_actual_spend > cumulative_estimated_contract_usage\n      then 'Burning Above Run Rate'\n      else 'Within Run Rate'\n    end AS RunRateFlag, case\n      when cumulative_actual_spend <= total_usage_amount\n      then 'Within Contract'\n      else 'Burst Usage'\n    end AS BurstFlag, case\n      when cumulative_actual_spend > total_usage_amount\n      then 1\n      else 0\n    end AS DidBurst, MAX_BY(estimated_contract_used, usage_date)  FILTER (WHERE TimePeriodFlag != 'Future') AS MostRecentEstimatedBurnProportion, MAX_BY(actual_contract_used, usage_date)  FILTER (WHERE TimePeriodFlag != 'Future') AS MostRecentActualBurnProportion\nfrom\n    clean_burn GROUP BY ALL ),\n remaining_tcv AS ( select\n    *, COALESCE((select\n    MIN(usage_date) AS burst_date\nfrom\n    with_flags\nwhere\n    DidBurst = 1)::date::string, 'Not Bursting') AS BurstDate, -- Contract remaining total_usage_amount - cumulative_actual_spend AS contract_usage_remaining, total_usage_amount + total_support_amount AS total_contract_value, (total_usage_amount + total_support_amount) - (cumulative_actual_spend + cumulative_actual_spend_support) AS contract_total_remaining\nfrom\n    with_flags ) select\n    *\nfrom\n    remaining_tcv --WHERE u_usage_date IS NOT NULL -- Will not look into future past current usage",
    "parameters": [
      {
        "displayName": "contract_start_date",
        "keyword": "contract_start_date",
        "dataType": "DATE",
        "defaultValue": "2024-01-01T00:00:00.000"
      },
      {
        "displayName": "contract_end_date",
        "keyword": "contract_end_date",
        "dataType": "DATE",
        "defaultValue": "now/d"
      },
      {
        "displayName": "usage_amount",
        "keyword": "usage_amount",
        "dataType": "DECIMAL",
        "defaultValue": "3000000"
      },
      {
        "displayName": "support_amount",
        "keyword": "support_amount",
        "dataType": "DECIMAL",
        "defaultValue": "500000"
      },
      {
        "displayName": "discounts_by_product",
        "keyword": "discounts_by_product",
        "dataType": "STRING",
        "defaultValue": "sql=0.0;VECTOR_SEARCH=0.0;ALL_PURPOSE=0.0;MODEL_SERVING=0.0;JOBS=0.0;INTERACTIVE=0.0;LAKEHOUSE_MONITORING=0.0;DLT=0.0"
      },
      {
        "displayName": "price_table",
        "keyword": "price_table",
        "dataType": "STRING",
        "defaultValue": "system.billing.list_prices"
      }
    ]
  }
]